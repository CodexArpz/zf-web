{
    "expand": "html",
    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-961",
    "key": "ZF-961",
    "fields": {
        "summary": {
            "name": "summary",
            "type": "java.lang.String",
            "value": "Proposed Feature: Enable Zend_Date::now() \/ Zend_TimeSync to interoperate"
        },
        "timetracking": {
            "name": "timetracking",
            "type": "com.atlassian.jira.issue.fields.TimeTrackingSystemField"
        },
        "issuetype": {
            "name": "issuetype",
            "type": "com.atlassian.jira.issue.issuetype.IssueType",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/issueType\/4",
                "name": "Improvement",
                "subtask": false
            }
        },
        "votes": {
            "name": "votes",
            "type": "com.atlassian.jira.issue.fields.VotesSystemField",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-961\/votes",
                "votes": 0,
                "hasVoted": false
            }
        },
        "security": {
            "name": "security",
            "type": "com.atlassian.jira.issue.security.IssueSecurityLevel"
        },
        "resolution": {
            "name": "resolution",
            "type": "com.atlassian.jira.issue.resolution.Resolution",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/resolution\/1",
                "name": "Fixed"
            }
        },
        "fixVersions": {
            "name": "fixVersions",
            "type": "com.atlassian.jira.project.version.Version",
            "value": [
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/version\/10172",
                    "id": 10172,
                    "description": "Minor Release",
                    "name": "1.5.0",
                    "userReleaseDate": "17\/Mar\/08",
                    "archived": true,
                    "releaseDate": "2008-03-17",
                    "released": true
                }
            ]
        },
        "resolutiondate": {
            "name": "resolutiondate",
            "type": "java.util.Date",
            "value": "2007-12-01T14:04:34.000+0000"
        },
        "reporter": {
            "name": "reporter",
            "type": "com.opensymphony.user.User",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                "name": "gavin",
                "displayName": "Gavin",
                "active": true
            }
        },
        "created": {
            "name": "created",
            "type": "java.util.Date",
            "value": "2007-02-23T14:21:53.000+0000"
        },
        "updated": {
            "name": "updated",
            "type": "java.util.Date",
            "value": "2008-03-21T16:25:44.000+0000"
        },
        "customfield_10041": {
            "name": "Tags",
            "type": "com.atlassian.jira.plugin.system.customfieldtypes:labels"
        },
        "description": {
            "name": "description",
            "type": "java.lang.String",
            "value": "I suggest we consider another integration point between Zend_TimeSync() and Zend_Date().  All code using Zend_Date::now() might potentially benefit, if this function returned an \"adjusted\" date made more accurate by using Zend_TimeSync.  However, several pototential problems must be solved before such a feature could be added:\n\n1) Zend_TimeSync should *not* be used to query SNTP\/NTP time servers frequently (e.g. once per web page request is *very* bad idea).\n2) Feature should be optional, and only enabled if explicitly requested by the develoepr\n3) Avoid coupling Zend_TimeSync to Zend_Date as much as possible (e.g. it should remain possible to use Zend_Date without loading \/ requiring Zend_TimeSync).\n4) The Zend_Date::now() function would need enhancement:\n{code}\npublic static function now($locale = null)\n{    return new Zend_Date(time(), Zend_Date::TIMESTAMP, $locale);    }\n{code}\n\nFor example, if the static public variable Zend_Date::TIMESYNC === true, then the function above would use Zend_TimeSync() to retrieve an offset needed to \"guesstimate\" the current time, just like I suggested in ZF-932.  However, this proposal is slightly more complex, because we need to avoid making Zend_TimeSync actually query NTP\/SNTP servers everytime Zend_Date::now() is called.  Also, if this feature is added, it needs to remain optional and not force everyone to {require_once 'Zend\/TimeSync.php'}, they use Zend_Date.  Thus, Zend_Date::now() would need to be \"smart\" and require the right classes, if needed, and use caching to prevent abuse and over-using of NTP\/SNTP time servers (also an issue with the Zend_TimeSync class whether or not any other ZF classes are used).\n\nExample Use Case:\n{code}\n$date1 = new Zend_Date();\n\/\/ $date1 has an *unadjusted* time === time()\n\n\/\/ global side-effect changing behavior of Zend_Date::now()\nZend_Date::nowUsesTimeSync(true);\n\n$date2 = new Zend_Date();\n\/\/ $date2 is adjusted by an offset determined by Zend_TimeSync (i.e. a cached value)\n\n\/\/ equivalent to new Zend_Date(), and also adjusted by the offset\n$date3 = Zend_Date::now();\n{code}\n\nAgain, this Jira \"issue\" is a suggested feature improvement, and discussion is encouraged by all who wish to participate.  The idea  in this posted issue is to encourage discovery of potential problems and especially to propose solutions for any of these potential problems, so that the value of the feature can be enjoyed without any \"cons\"."
        },
        "priority": {
            "name": "priority",
            "type": "com.atlassian.jira.issue.priority.Priority",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/priority\/4",
                "name": "Minor"
            }
        },
        "duedate": {
            "name": "duedate",
            "type": "java.util.Date"
        },
        "customfield_10022": {
            "name": "Fix Version Priority",
            "type": "com.atlassian.jira.plugin.system.customfieldtypes:select"
        },
        "watcher": {
            "name": "watcher",
            "type": "watcher",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-961\/watchers",
                "isWatching": false,
                "watchCount": 1
            }
        },
        "worklog": {
            "name": "worklog",
            "type": "worklog",
            "value": [

            ]
        },
        "status": {
            "name": "status",
            "type": "com.atlassian.jira.issue.status.Status",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/status\/5",
                "name": "Resolved"
            }
        },
        "labels": {
            "name": "labels",
            "type": "com.atlassian.jira.issue.label.Label",
            "value": [

            ]
        },
        "assignee": {
            "name": "assignee",
            "type": "com.opensymphony.user.User",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                "name": "thomas",
                "displayName": "Thomas Weidner",
                "active": true
            }
        },
        "links": {
            "name": "links",
            "type": "issuelinks",
            "value": [
                {
                    "issueKey": "ZF-932",
                    "issue": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-932",
                    "type": {
                        "name": "Dependency",
                        "direction": "OUTBOUND",
                        "description": "depends on"
                    }
                },
                {
                    "issueKey": "ZF-987",
                    "issue": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-987",
                    "type": {
                        "name": "Dependency",
                        "direction": "OUTBOUND",
                        "description": "depends on"
                    }
                }
            ]
        },
        "attachment": {
            "name": "attachment",
            "type": "attachment",
            "value": [

            ]
        },
        "sub-tasks": {
            "name": "sub-tasks",
            "type": "issuelinks",
            "value": [

            ]
        },
        "versions": {
            "name": "versions",
            "type": "com.atlassian.jira.project.version.Version",
            "value": [

            ]
        },
        "project": {
            "name": "project",
            "type": "com.atlassian.jira.project.Project",
            "value": {
                "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/project\/ZF",
                "key": "ZF",
                "name": "Zend Framework",
                "roles": {

                }
            }
        },
        "components": {
            "name": "components",
            "type": "com.atlassian.jira.bc.project.component.ProjectComponent",
            "value": [
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/component\/10072",
                    "id": 10072,
                    "name": "Zend_Date",
                    "description": "Zend_Date is the basic library for the handling of all date, time and calendar-related issues.",
                    "isAssigneeTypeValid": false
                }
            ]
        },
        "comment": {
            "name": "comment",
            "type": "com.atlassian.jira.issue.fields.CommentSystemField",
            "value": [
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/12913",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "This would not work,  because how should Zend_Date know which Timeservers the coupled TimeSync should request...\n\nA user would always have to create a TimeSync object to request timeservers...\n\nAnd as soon as you have your TimeSync object you should use Zend_TimeSync->getdate and you will have a date object with the actual time from the timeserver... \n\nIn my opinion there is no good way to back-couple these two classes.\n\nZend_TimeSync is too problematic to have it directly integrated within Zend_Date. Even if this is made clear within the documentation.\n\nSomeone who needs timeservers should always use Zend_TimeSync to get the right date object.\nHe will then have to read the docu or the APIdoc of Zend_TimeSync which will lead him automatically in knowing the problems and benefit of timeservers.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-02-23T14:40:28.000+0000",
                    "updated": "2007-02-23T14:40:28.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/12916",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "This could work, if \"enabled [when] explicitly requested by the developer\".  I did not specify the mechanism how this could be accomplished, and there is room for creativity.  \n\nIf a developer wants to TimeSync \"enable\" an entire ZF application, it could be as easy as this:\n{code}\n$server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \n$result = $server->getDate();\nZend_Date::nowUsesTimeSync($result);\n\n$date = new Zend_Date(); \/\/ $date is automatically adjusted by the offset determined from $result\n$date = Zend_Date::now(); \/\/ $date is automatically adjusted by the offset determined from $result\n{code}\n\nHowever, if reasonable precautions were employed to prevent abuse of the time server, we could use http:\/\/www.pool.ntp.org\/ and eliminate the client-side code above.  Yes, there could be problems if implemented wrong, but there are solutions available for correct implementations.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-02-23T16:21:32.000+0000",
                    "updated": "2007-02-23T16:21:32.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/12918",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "In the most extreme case of keeping these two classes separate, the developer could be forced to do something like this (or maybe use a different Zend_TimeSync method than getInfo() to suggest an offset):\n\n{code}\n$server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \n$result = $server->getDate();\nZend_Date::nowUsesTimeSync($result->getInfo());\n{code}\n\nThe benefit comes from making existing ZF code suddenly use time adjusted dates\nby merely poking a configuration value into Zend_Date's class.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-02-23T16:58:16.000+0000",
                    "updated": "2007-02-23T16:58:16.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/12919",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "Note that any use of a static class variable holding a time offset (used to adjust time() to the \"accurate\" time) necessitate the use of this variable by Zend_Date_DateObject::_getTime(), in order to avoid breaking isToday() and friends.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-02-23T17:06:31.000+0000",
                    "updated": "2007-02-23T17:06:31.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/12920",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": " I am less concerned by how Zend_Date::now() and Zend_Date_DateObject::_getTime() access a \"global\" shared offset .. but I'm more concerned that it is possible to make them use this shared time offset, without losing the cool feature of making individual Zend_Date object's have a private offset that take precedence over the shared offset.\n\nI am somewhat worried about Zend_TimeSync, because of the danger of abusing NTP servers.  If we provide a more complete integrated \"solution\", there is less chance people will use Zend_TimeSync in bad ways that pound on NTP servers, giving ZF a bad reputation.\n\nIf we provide the code and solution to make Zend_Date rely on an offset generated by Zend_TimeSync, then we have more control over the use of Zend_TimeSync, and can insure that the offset is cached for a reasonable period of time, instead of a developer literally putting the following code into their bootstrap (very bad, because it pounds on NTP servers, when the ZF app is on a busy website):\n\n{code}\n$server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \n$result = $server->getDate();\nZend_Date::nowUsesTimeSync($result->getInfo());\n{code}",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-02-23T17:32:16.000+0000",
                    "updated": "2007-02-23T17:32:16.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/12924",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=andries",
                        "name": "andries",
                        "displayName": "Andries Seutens",
                        "active": true
                    },
                    "body": "Gavin, I am worried about this too. Perhaps a forced internal caching mechanism (eg Zend_Cache) wouldn't be such a bad idea at all? We could implement this with the possibility of abstraction, which would make it possible for the developer to use his\/her own caching mechanism, or totally avoid the caching (if he\/she knows what they are doing).\n\nI am just brainstorming out loud, and i have no actual use cases yet. I encourage everybody to think with us, and find a proper solution.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=andries",
                        "name": "andries",
                        "displayName": "Andries Seutens",
                        "active": true
                    },
                    "created": "2007-02-24T04:54:12.000+0000",
                    "updated": "2007-02-24T04:54:12.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/12925",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "Please keep the issues seperated.\n\nThis issue is not about stealthing or improving Zend_TimeSync...\nIt's a Zend_Date issue.\n\nI think it would be better to have an own new issue about improvements for Zend_Timesync.\n\nRelated to this issue and to write down what we discussed yesterday:\n\n1.) A user must not have the possibility to give an Syncronisation Offset to Zend_Date per hand. This would corrupt the actual implementation of Zend_Date.\n\n2.) It is no problem to have also Zend_Date::now() working with the TimeSync offset but there are some prerequisits which have to be included before this issue can be implemented\n\n2.1) There must be a way to store the Zend_Date object especially the private variables into a framework cache\n\n2.2) Zend_Date must only interoperate with an Zend_Timesync object. What makes problems here is the offset between time() and the returned real time. Working with own generated times already works. Also working with TimeSync object works (see ZF-932). What we speaking of here is having the TimeSync offset stored internally so it can be used when a user creates a Date object afterwards as TimeSync should run only once per usersession or even once per day.\n\n2.3) Zend_Timesync has to be stealthed and improved to prevent problems with the Stratunm servers if they were flooded with Zend Framework requests.\n\n2.4) Zend_Timesync has to implement a caching mechanism to prevent these flooding\n\n3) The actual API of Zend_Date should not change. The offset has to be known automatically, to prevent missuse. Storing it anywhere within the framework is no problem as long as we can make sure that private\/protected stored variables can not be changed by other classes. ",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-02-24T05:17:24.000+0000",
                    "updated": "2007-02-24T05:17:24.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/12926",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "A way which does not corrupt the API would be \n\n{code}\n$server = new Zend_TimeSync('ntp:\/\/pool.ntp.org', 'pool');\n$date = new Zend_Date($server);\n{code}\n\nyou can serialize \/ deserialize the TimeSync object and use it with Zend_Date...\nThis is how this issue works NOW... this is already implemented by ZF-932.\n\n{code}\n$server = new Zend_TimeSync('ntp:\/\/pool.ntp.org', 'pool');\n$store = serialize($server);\n\n\/\/.....\n\n$server = unserialize($store);\n$date = new Zend_Date($server);\n{code}\n\nworks already...\nonly one more line than what you proposed.\nAnd the user has explicit to say that he wants to use the TimeSync offset which is the better way in my eyes than having this done in background.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-02-24T05:27:07.000+0000",
                    "updated": "2007-02-24T05:27:07.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13049",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "Are there any actual problems supporting the following use case involving {{nowUsesTimeSync()}}?\n{code}\n$server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \n$result = $server->getDate();\nZend_Date::nowUsesTimeSync($server);\n$date = Zend_Date::now(); \/\/ $date is adjusted with the offset determined by Zend_TimeSync\n{code}",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-02-28T14:54:53.000+0000",
                    "updated": "2007-02-28T14:54:53.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13054",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "No cache mechanism implemented within Zend_Date\nThe user does not know that he uses timesync values from now on...\n\nTherefor the approach to explicit give the server to Zend_Date is more accurate.\nAlso when you always have to give Zend_Date the server explicit with an parameter you always have to know and recognise that you are not using time() but timeserver.\n\nIt is no problem also to have\n{code}\n$date = Zend_Date::now($server);\n{code}\nimplemented.\n\nAlso for a user it would be no problem when he desides to change from time() to timeserver to change his complete code from now(); to now($server);... just a search and replace within the code, 3 mouseclicks with a modern GUI.\n\n$server should be serializeable and deserializeable but this are problems of Zend_TimeSync and not of this issue.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-02-28T15:32:16.000+0000",
                    "updated": "2007-02-28T15:32:16.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13056",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "Why should we require this:\n\n{code}\n$server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \n$result = $server->getDate();\n$date1 = Zend_Date::now($server);\n$date2 = Zend_Date::now($server);\n$date3 = Zend_Date::now($server);\n{code}\n\nwhen we can make this work:\n{code}\n$server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \n$result = $server->getDate();\nZend_Date::nowUsesTimeSync($server);\n$date = Zend_Date::now(); \/\/ $date is adjusted with the offset determined by Zend_TimeSync\n{code}\n\nFor a \"cache mechanism\", all we need to do is:\n{code}\npublic function nowUsesTimeSync(Zend_TimeSync $server)\n{\n    $result = $server->getDate();\n    $info = $result->getInfo()\n    self::$_timeServerOffset = $info['offset'];\n}\n{code}\n\n{quote}.. search and replace ..{quote}\nI think search and replace is not an acceptable solution.  What if the developer can not change the code?  What if the code is part of another module or library?  What if sometimes the code should use the offset, and other times it should not?\n\nThe solution I've proposed does not have these problems, and could be made to work with Zend_Date.\n",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-02-28T16:19:54.000+0000",
                    "updated": "2007-02-28T16:19:54.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13058",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "Why would you have to use 3 date objects with the actual time ???\nThere will never be as much new date objects that you would have problems with adding $server by creation inmy opinion...\n\n{quote}\nFor a \"cache mechanism\", all we need to do is:\n\n{code}\npublic function nowUsesTimeSync(Zend_TimeSync $server)\n{\n    $result = $server->getDate();\n    $info = $result->getInfo()\n    self::$_timeServerOffset = $info['offset'];\n}\n{code}\n{quote}\n\nBut this does not cache the offset...\nWith this approach you have always to use nowUsesTimeSync before creating a Zend_Date object...\nAnd when you create a timeserver you can also work directly with getDate which returns you an offseted Date object.\n\nAnd also to mention...\nIf you want to use several offseted date objects you just have to clone the $result->getDate(); Date object.\n\n{code}\n$server = new Zend_TimeSync($myoptions);\n$date = new Zend_Date($server);\n\/\/ or $date = $server->getDate();\n\n$date2 = $date->clone();\n$date3 = $date->clone();\n{code}\n\nYou have to give the server only once.\n\nZend_Date is already a very huge class... with very much functionallity, even if it's very simple within its API... we should not add much more functionallity for now... it would become too complex for 1.0.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-02-28T16:44:58.000+0000",
                    "updated": "2007-02-28T16:44:58.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13059",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "{quote}Why would you have to use 3 date objects with the actual time ???{quote}\n\nI was trying to show a simple example.  In actual code for a real-world web application, there might be many more than 3 date objects in use, scattered throughout the code.  One developer might write one part of a web app, and another developer another part, etc.\n\nThe offset is cached internally by Zend_TimeSync, so that is not a problem.\nA ZF app only needs to use {{nowUsesTimeSync()}} once, in their bootstrap to enable their *entire* application to use accurate dates, adjusted using the offset supplied by Zend_TimeSync.  This approach is simple, efficient, and does not require \"search & replac\" on existing code.\n\nI don't buy the argument that the proposed {{nowUsesTimeSync()}} is too complex to add to Zend_Date.  It is only 3 lines of code.  A couple additional lines of code would be needed to enable the existing now() method to use this offset.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-02-28T17:02:36.000+0000",
                    "updated": "2007-02-28T17:02:36.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13062",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "Your approach only works if the date object is also used within the bootstrap file.\nIf you have a subclass loading Zend_Date itself and creating a new object it would also not have the offset because it's not cached. This only works if all use the bootstrap file.\n\nWhen we have a object created with \n\n{code}\n$date = new Zend_Date($timesyncserver);\n{code}\n\nits also no problem to have\n\n{code}\n\/\/ syncronise boolean|Zend_TimeSync\npublic static function now($syncronise = true) {\n    if ($syncronise) {\n        return new Zend_Date($timesyncserver);\n    }\n    return new Zend_Date(time());\n}\n\/\/ only example code\n{code}\n\nAnd this would be no problem because then you can decide if you want to have a syncronised object or not. If you say syncronised (which is standard behaviour) and you have not initialised a timeserver before you will get time() because offset is 0. Giving a \"false\" you would have time() returned.\n\nThis is a much nicer way then having a function \"nowusestimesync()\" even if it would have more than 3 lines of code for the implementation.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-03-01T01:18:27.000+0000",
                    "updated": "2007-03-01T01:18:27.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13065",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "{quote}Your approach only works if the date object is also used within the bootstrap file.{quote}\n\nNo.  All calls to Zend_Date::now()  would return an \"adjusted\" date, after a single call to {{nowUsesTimeSync()}}, which should be made in the application bootstrap, to enable all further usage of Zend_Date to use \"synchronized\" times for the duration of the current script execution.\n\nThe offset is cached for the duration of the request by {{nowUsesTimeSync()}}.  Why would a subclass of Zend_Date() have problems? I see no problems.\n\nAgain, we need a way to \"time-sync-enable\" Zend_Date, without requiring a developer to \"search & replace\" code (including code they might not have written).\n\nInstead of {{ public static function now($syncronise = true) }}, I would suggest:\n\n{code}\npublic static function now($syncronise = null) {\n    if (self::$_timeServerOffset && $synchronize !== false) {\n        return new Zend_Date(time() + self::$_timeServerOffset);\n    }\n    return new Zend_Date(time());\n}\n\n\/\/ For a \"cache mechanism\", all we need to do is:\n\npublic function nowUsesTimeSync(Zend_TimeSync $server)\n{\n    $result = $server->getDate();\n    $info = $result->getInfo()\n    self::$_timeServerOffset = $info['offset'];\n}\n\n\/\/ Use case:\nfunction bootstrap()\n{ \n    .\n    .\n    $server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \n    Zend_Date::nowUsesTimeSync($server);\n    .\n    .\n}\n\n\/\/ whenever a date is needed, regardless of where in the user's ZF application (even code this developer did not write\/maintain):\n$date = Zend_Date::now(); \/\/ $date is adjusted with the offset determined by Zend_TimeSync\n{code}\n\nThe key here is that a developer can toggle the behavior of Zend_Date component to generate synchronized dates by setting a class property, instead of having to specify this behavior for every single instance object.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-03-01T13:43:18.000+0000",
                    "updated": "2007-03-01T13:43:18.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13067",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "I think we are speaking the same but I feel missunderstood by the details you are sticked in...\n\n*) I said this only works when Zend_Date is used within the bootstrap.\nYou said no... this has to be done in application bootstrap... my english is not so good, but we are speaking of the same thing in my opinion.\n\n*) Please forget \"nowusestimesync\"... :-(\n\n*) My idea with the new approach for now() does not need to search and replace for the developer.\nThe idea is that now() returns the date with offset when the offset is set within Zend_Date or a timeserver is given as parameter.\n\n*) We say default is with offset or without offset... these are details we can change simply afterwards.\nI would say default is use the offset when avaiable.\n\n*) now() should be changed to accept a timeserver as input for same behaviour as the constructor.\n\n*) Now the user has to do getDate from the timeserver...\nIt's no problem to have this implemented within the constructor and now()...\nSo there is no need for the nowusestimeserver function.\n\nThis function is what I dont like in the proposed functionality.\n\nnow() can simply be changed to do additionally the same as your proposed nowusestimesync function.\n\nnow() -> returns new date object with offset if set\nnow(false) -> returns new date object with time() without offset\nnow(true, TimeServer) -> returns new date object with setting new offset from this timeserver for future use\nnow(true, RESET_OFFSET) -> resets offset to 0 in future use returning new date object\n",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-03-01T14:47:03.000+0000",
                    "updated": "2007-03-01T14:47:03.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13068",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "My example does not use a Zend_Date object in the bootstrap.\n\nI proposed using {{nowUsesTimeSync()}} to set the offset used by the Zend_Date class for future calls to any of the Zend_Date methods needing the current time.  I purposely chose a descriptive name for this function for this JIRA issue, but I expect the final name of the function to be different.  I suggest we follow the slowly emerging pattern of using \"setOptions()\" class methods with Zend_Date,  instead of overloading now() with functionality related to setting options in the class.  See {{setOptions()}} in Zend_Session or Zend_Console_Getopt.\n\nCombining a factory method ({{now()}}) with a method altering class behavior ({{nowUsesTimeSync()}}) is not a common practice.  Can we keep these two methods separate, with descriptive function names?  If they are combined into one function as you proposed, then the bootstrap would require the creation an instance object of Zend_Date in order to set an option in Zend_Date.\n\nAlso, my use of {{now()}} was just an example.  Setting the Zend_Date option to use time synch should affect *all* methods (including {{_gettime()}}) that require the current time().  The main idea should be supporting toggling a config \"switch\" in the Zend_Date class to make all Zend_Date methods use the offset to return time synchronized dates, when the current time is needed or used.  With this feature, developers can then set a simple configuration option in Zend_Date (one line of code in their application bootstrap), and then know that all relevant dates will be adjusted with a time offset determined by Zend_TimeSync.\n\n\n",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-03-01T15:27:20.000+0000",
                    "updated": "2007-03-01T15:27:20.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13080",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "Why is \n\nnow($timeserver);\n\na problem...\nFrom Now on use the timeserver offset... I would expect this is standard behaviour.\n\nAnd you do not have to create an object.\n\nZend_Date::now($timeserver);\n\nalso sets the offset without that you will have to create a date object... I see no problem on this approach.\nAll methods then use the stored offset afterwards... you have not to set it once more... just one call of Zend_Date::now() is all you have to do in your bootstrap file. This IS one line of code. And it effects ALL 4 methods that use _gettime().\n\nAnyway... we are discussing here massive for nothing because this issue will not be implemented before Zend_Timesync is not save to do so... we have enough other opened issues which we shall target and solve...\n\nAs soon as Zend_TimeSync is as save as it should be, we can drive this issue further... it costs me 1h per day and I have only 2 hours per day... this makes me unhappy :-\/",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-03-01T17:28:32.000+0000",
                    "updated": "2007-03-01T17:28:32.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13082",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "It is a problem because Zend_Date::now() is supposed to create an instance of Zend_Date having the current time.   If the function returns true\/false on some input and returns an instance object for no input .. that is mixing things in a confusing way.  Users should know that now() simply returns an instance object with the current time, and that class options can be set using {{setOptions()}}.\n\nAdding unrelated functionality to this function ({{now()}}) is a problem.  Adding functionality to {{now()}} that modifies the behavior of future uses of _getTime(), now() and other methods directly or indirectly dependent on these combines unrelated functionality into the same method.\n\nOther ZF components use {{setOptions()}} to set options on the component.  Why not use {{setOptions()}}?\nAlso, the {{usePhpDateFormat()}} can become an option supported by {{setOptions()}}.  Keeping a single, consistent API approach for all options reduces learning curves, simplifies integration with applications, and other benefits.  \n\nIn addition to {{Zend_Session::setOptions}}, for an idea of what might be possible in the long-term, see:\nhttp:\/\/framework.zend.com\/wiki\/x\/Sks\n\nYes, there is no \"Fix Version\" yet for this issue.  \"Fix Versions\" provide important guidelines for priority.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-03-01T20:37:51.000+0000",
                    "updated": "2007-03-01T20:37:51.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13087",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "There is no \"fix version\" avaiable...\n\nZend_Date was never proposed to work internally with Zend_TimeSync because of the problems which Zend_Timesync produces by heavily useage of the Stratum Servers.\n\nZend_Date was only changed to allow Zend_TimeSync to return a proper date object.\n\nIF the problems within Zend_TimeSync and user missuse can be solved it would be no problem to implement this feature. But I will not implement it with the actual problems of Zend_TimeSync and users not knowing what they exactly do. This would lead to a negative image of Zend Framework because of flooding Stratum Servers. \n\nA strict NO from me if this can not be solved.\n\nI see no problem in having static setOption() integrated.\nI misliked to implement the usePhpDateFormat also... but it was told and it seemed to be necessary.\nBut I am strictly against nowUsesTimeSync()... \nNext would be a function \"toStringUsesPhpDateFormatButOnlyReturningEnglishLocalizedValues\" ???\nNonono.... this can not be our way...\n\nWHEN we decide for now not to support a timeserver parameter then also the constructor should not accept it.\nBUT this would also mean that the getDate() function of Zend_Timesync is useless...\n\nAlso to mention...\nIt seems nice to have Zend_TimeSync strong coupled with Zend_Date... BUT we loose all possibilities of Zend_TimeSync this way.\nNo way to know what server was used, no setting of the namespace and no calling of a defined server are only a few things which came in my mind.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-03-02T01:24:36.000+0000",
                    "updated": "2007-03-02T01:24:36.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/13155",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "body": "{quote}\"IF the problems within Zend_TimeSync and user missuse can be solved it would be no problem to implement this feature.\" {quote}\nSo far, I have not seen or heard anyone disagree about the importance of solving ZF-987, before any sort of integration between Zend_Date and Zend_TimeSync.  Earlier, I added ZF-987 as a dependency of this issue (i.e. this issue can not be adequately solved until after ZF-987).\n\nIf ZF-987 is solved, then it should be possible to:\n{code}\n$server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \nZend_Date::setOptions(array('timesync' => $server));  \/\/ or $server->getInfo(), or whatever Zend_Date wants to compute the needed information\n$date = new Zend_Date();  \/\/ $date is adjusted based on the information from Zend_TimeSync\n{code}\n\nJust to throw out another idea for consideration, if a reasonable use case exists where computations are complex, then Zend_Date could simply accept a callback, instead of an instance of Zend_TimeSync.  A developer would then be responsible for implementing the callback, possibly using Zend_TimeSync.  For example:\n{code}\n$server = new Zend_TimeSync('ntp:\/\/serveraddress', 'alias');  \nZend_Date::setOptions(array('timesync' => $callback));  \/\/ or $server->getInfo(), or whatever Zend_Date wants to compute the needed information\n$date = new Zend_Date();  \/\/ $date is adjusted based on the results of something like: call_user_func($callback, time())\n{code}\n\nIn both alternatives above, the developer is in control, and has the ability to determine which time servers to use.  I've also spoken with Andries about the possibility of developer-supplied algorithms for selecting amongst a set of time servers to use, based on information dynamically gathered by Zend_TimeSync* classes.  For example, developers could select the time servers with the lowest latency.  I do not see any problems including this functionality with the two alternatives shown above in code.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=gavin",
                        "name": "gavin",
                        "displayName": "Gavin",
                        "active": true
                    },
                    "created": "2007-03-05T20:56:51.000+0000",
                    "updated": "2007-03-05T20:56:51.000+0000"
                },
                {
                    "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/comment\/17762",
                    "author": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "body": "Integrated with SVN-7015.\n\nNow there is a own option which can be set.\n\n{code}\n$server = new Zend_TimeSync('0.pool.ntp.org');\nZend_Date::setOptions(array('timesync' => $server));\n{code}\n\nThis sets the given offset for all new instances of Zend_Date independently of the way it is created.",
                    "updateAuthor": {
                        "self": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/user?username=thomas",
                        "name": "thomas",
                        "displayName": "Thomas Weidner",
                        "active": true
                    },
                    "created": "2007-12-01T14:04:34.000+0000",
                    "updated": "2007-12-01T14:04:34.000+0000"
                }
            ]
        }
    },
    "transitions": "http:\/\/framework.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-961\/transitions"
}