{
    "expand": "html",
    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-4253",
    "key": "ZF-4253",
    "fields": {
        "summary": {
            "name": "summary",
            "type": "java.lang.String",
            "value": "Memcache should support tags"
        },
        "timetracking": {
            "name": "timetracking",
            "type": "com.atlassian.jira.issue.fields.TimeTrackingSystemField"
        },
        "issuetype": {
            "name": "issuetype",
            "type": "com.atlassian.jira.issue.issuetype.IssueType",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issueType\/4",
                "name": "Improvement",
                "subtask": false
            }
        },
        "votes": {
            "name": "votes",
            "type": "com.atlassian.jira.issue.fields.VotesSystemField",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-4253\/votes",
                "votes": 0,
                "hasVoted": false
            }
        },
        "security": {
            "name": "security",
            "type": "com.atlassian.jira.issue.security.IssueSecurityLevel"
        },
        "resolution": {
            "name": "resolution",
            "type": "com.atlassian.jira.issue.resolution.Resolution",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/resolution\/2",
                "name": "Won't Fix"
            }
        },
        "fixVersions": {
            "name": "fixVersions",
            "type": "com.atlassian.jira.project.version.Version",
            "value": [

            ]
        },
        "resolutiondate": {
            "name": "resolutiondate",
            "type": "java.util.Date",
            "value": "2008-09-26T12:48:02.000+0000"
        },
        "reporter": {
            "name": "reporter",
            "type": "com.opensymphony.user.User",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=leason",
                "name": "leason",
                "displayName": "Lee Eason",
                "active": true
            }
        },
        "created": {
            "name": "created",
            "type": "java.util.Date",
            "value": "2008-09-11T11:16:15.000+0000"
        },
        "updated": {
            "name": "updated",
            "type": "java.util.Date",
            "value": "2011-06-01T13:48:40.000+0000"
        },
        "customfield_10041": {
            "name": "Tags",
            "type": "com.atlassian.jira.plugin.system.customfieldtypes:labels",
            "value": [
                "cache",
                "memcached"
            ]
        },
        "description": {
            "name": "description",
            "type": "java.lang.String",
            "value": "I have extended the Memcached backed to implement a tagging system.  I have not yet load tested or extensively bug tested this.  My improvement is for a specific project, but I've adapted my extended class for submission as a potential improvement.  Only a couple of methods are actually over-ridden here.  \n\nThe basic idea is that you use a cached array to track the keys.  When you save keys you retrieve the cached key array, add the ID being saved as another entry into each tag it is being associated with, and save the updated tag array.  To remove by tag you look up the tag in the global tags array and loop through the entries deleting each one from memcache and updating the cached tag array.\n\nHere is my example implementation:\n{noformat}\nclass KeyEnabled_Memcached extends Zend_Cache_Backend_Memcached\n{\n\n\tprivate function getTagListId()\n\t{\n\t\treturn \"MyTagArrayCacheKey\";\n\t}\n\t\n\tprivate function getTags()\n\t{\n\t\tif(!$tags = $this->_memcache->get($this->getTagListId()))\n\t\t{\n\t\t\t$tags = array();\n\t\t}\n\t\treturn $tags;\n\t}\n\t\n\tprivate function saveTags($id, $tags)\n\t{\n\t\t\/\/ First get the tags\n\t\t$siteTags = $this->getTags();\n\t\t\n\t\tforeach($tags as $tag)\n\t\t{\n\t\t\t$siteTags[$tag][] = $id;\n\t\t}\n\t\t$this->_memcache->set($this->getTagListId(), $siteTags);\t\t\n\t}\n\t\n\tprivate function getItemsByTag($tag)\n\t{\n\t\t$siteTags = $this->_memcache->get($this->getTagListId());\n\t\treturn isset($siteTags[$tag]) ? $siteTags[$tag] : false;\n\t}\n\n    \/**\n     * Save some string datas into a cache record\n     *\n     * Note : $data is always \"string\" (serialization is done by the\n     * core not by the backend)\n     *\n     * @param  string $data             Datas to cache\n     * @param  string $id               Cache id\n     * @param  array  $tags             Array of strings, the cache record will be tagged by each string entry\n     * @param  int    $specificLifetime If != false, set a specific lifetime for this cache record (null => infinite lifetime)\n     * @return boolean True if no problem\n     *\/\n    public function save($data, $id, $tags = array(), $specificLifetime = false)\n    {\n        $lifetime = $this->getLifetime($specificLifetime);\n        if ($this->_options['compression']) {\n            $flag = MEMCACHE_COMPRESSED;\n        } else {\n            $flag = 0;\n        }\n        $result = $this->_memcache->set($id, array($data, time()), $flag, $lifetime);\n        if (count($tags) > 0) {\n        \t$this->saveTags($id, $tags);\n        }\n        return $result;\n    }\n\n    \/**\n     * Clean some cache records\n     *\n     * Available modes are :\n     * 'all' (default)  => remove all cache entries ($tags is not used)\n     * 'old'            => remove too old cache entries ($tags is not used)\n     * 'matchingTag'    => remove cache entries matching all given tags\n     *                     ($tags can be an array of strings or a single string)\n     * 'notMatchingTag' => remove cache entries not matching one of the given tags\n     *                     ($tags can be an array of strings or a single string)\n     *\n     * @param  string $mode Clean mode\n     * @param  array  $tags Array of tags\n     * @return boolean True if no problem\n     *\/\n    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array())\n    {\n        if ($mode==Zend_Cache::CLEANING_MODE_ALL) {\n            return $this->_memcache->flush();\n        }\n        if ($mode==Zend_Cache::CLEANING_MODE_OLD) {\n            $this->_log(\"Zend_Cache_Backend_Memcached::clean() : CLEANING_MODE_OLD is unsupported by the Memcached backend\");\n        }\n        if ($mode==Zend_Cache::CLEANING_MODE_MATCHING_TAG) {\n        \t$siteTags = $newTags = $this->getTags();\n        \tif(count($siteTags))\n        \t{\n\t        \tforeach($tags as $tag)\n\t        \t{\n\t        \t\tif(isset($siteTags[$tag]))\n\t        \t\t{\n\t        \t\t\tforeach($siteTags[$tag] as $item)\n\t        \t\t\t{\n\t        \t\t\t\t\/\/ We call delete directly here because the ID in the cache is already specific for this site\n\t        \t\t\t\t$this->_memcache->delete($item);\n\t        \t\t\t}\n\t        \t\t\tunset($newTags[$tag]);\n\t        \t\t}\n\t        \t}\n\t        \t$this->_memcache->set($this->getTagListId(),$newTags);\n        \t}\n        }\n        if ($mode==Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG) {\n        \t$siteTags = $newTags = $this->getTags();\n        \tif(count($siteTags))\n        \t{\n        \t\tforeach($siteTags as $siteTag => $items)\n        \t\t{\n        \t\t\tif(array_search($siteTag,$tags) === false)\n        \t\t\t{\n        \t\t\t\tforeach($items as $item)\n        \t\t\t\t{\n        \t\t\t\t\t$this->_memcache->delete($item);\n        \t\t\t\t}\n        \t\t\t\tunset($newTags[$siteTag]);\n        \t\t\t}\n        \t\t}\n        \t\t$this->_memcache->set($this->getTagListId(),$newTags);\n        \t}\n        }\n    }\n}\n{noformat}"
        },
        "priority": {
            "name": "priority",
            "type": "com.atlassian.jira.issue.priority.Priority",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/priority\/4",
                "name": "Minor"
            }
        },
        "duedate": {
            "name": "duedate",
            "type": "java.util.Date"
        },
        "customfield_10022": {
            "name": "Fix Version Priority",
            "type": "com.atlassian.jira.plugin.system.customfieldtypes:select"
        },
        "watcher": {
            "name": "watcher",
            "type": "watcher",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-4253\/watchers",
                "isWatching": false,
                "watchCount": 2
            }
        },
        "worklog": {
            "name": "worklog",
            "type": "worklog",
            "value": [

            ]
        },
        "status": {
            "name": "status",
            "type": "com.atlassian.jira.issue.status.Status",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/status\/5",
                "name": "Resolved"
            }
        },
        "labels": {
            "name": "labels",
            "type": "com.atlassian.jira.issue.label.Label",
            "value": [

            ]
        },
        "assignee": {
            "name": "assignee",
            "type": "com.opensymphony.user.User",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=fab",
                "name": "fab",
                "displayName": "Fabien MARTY",
                "active": true
            }
        },
        "links": {
            "name": "links",
            "type": "issuelinks",
            "value": [

            ]
        },
        "attachment": {
            "name": "attachment",
            "type": "attachment",
            "value": [

            ]
        },
        "sub-tasks": {
            "name": "sub-tasks",
            "type": "issuelinks",
            "value": [

            ]
        },
        "versions": {
            "name": "versions",
            "type": "com.atlassian.jira.project.version.Version",
            "value": [
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/version\/10240",
                    "id": 10240,
                    "description": "Minor Release",
                    "name": "1.6.0",
                    "userReleaseDate": "02\/Sep\/08",
                    "archived": false,
                    "releaseDate": "2008-09-02",
                    "released": true
                }
            ]
        },
        "project": {
            "name": "project",
            "type": "com.atlassian.jira.project.Project",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/project\/ZF",
                "key": "ZF",
                "name": "Zend Framework",
                "roles": {

                }
            }
        },
        "components": {
            "name": "components",
            "type": "com.atlassian.jira.bc.project.component.ProjectComponent",
            "value": [
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/component\/10028",
                    "id": 10028,
                    "name": "Zend_Cache",
                    "isAssigneeTypeValid": false
                }
            ]
        },
        "comment": {
            "name": "comment",
            "type": "com.atlassian.jira.issue.fields.CommentSystemField",
            "value": [
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/24500",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=fab",
                        "name": "fab",
                        "displayName": "Fabien MARTY",
                        "active": true
                    },
                    "body": "tags system for memcache, APC or xcache backends are not reliable because the system can drop any of your record to make some space for other records\n\nso your proposal is good but not reliable\n\nif memcache drop your MyTagArrayCacheKey record, what about CLEANING_MODE_NOT_MATCHING_TAG or CLEANING_MODE_MATCHING_TAG ?\n\nin SVN trunk, there is a completly new backend called \"TwoLevels\" :\n- the fast level can be memcache backend\n- the slow level (but reliable) can be the file backend\n\nThis virtual backend has plenty of advantages and of course support tags (throw the reliable backend)\n\nPlease have a look at this.\n\n\n\n\n\n",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=fab",
                        "name": "fab",
                        "displayName": "Fabien MARTY",
                        "active": true
                    },
                    "created": "2008-09-12T11:06:19.000+0000",
                    "updated": "2008-09-12T11:06:19.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/31744",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=aleksiu",
                        "name": "aleksiu",
                        "displayName": "Aleksi Ursin",
                        "active": true
                    },
                    "body": "The lack of memcached tags support missing should atleast be documented somewhere.\n\nFurthermore, it's a \"hack\" so to speak to make work for file cache aswell, so i don't see any reason why not to implement for Memcached aswell. However this solution, while rather simple, does not offer good performance.\n\nThis proposes one big array for all the keys and their tags, which does not work very well if you use millions upon millions of keys (enough to make \/dev\/shm\/cache based \"filecache\" to crawl due to huge directory sizes), and would translate to huge amounts of downtime on such systems, due to constant memory over consumption.\n\nPlus, when saving a new key you would need to load that, and save it there, not working therefore.\n\nI propose it should work something along these lines:\n - tag based index keys, ie. tag1, tag2 have: internal-metadata-tag1, internal-metadata-tag2 index arrays cached\n - index array for different tags, ie. containing all the tags currently being employed. works if relatively small amount of different tags.\n\nAs for the memcached possibly cleaning them away: I doubt because these are constantly accessed, therefore constantly fresh, therefore not going to be emptied. To be certain of this, a temporary directory as a backup for these could be used, or solely for these, ie. file cache. However, that option neither is optimal, unless used against \/dev\/shm (What's similar for Windows?). If this data disappears, flush all in memcache (make this optional)",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=aleksiu",
                        "name": "aleksiu",
                        "displayName": "Aleksi Ursin",
                        "active": true
                    },
                    "created": "2009-06-11T03:19:08.000+0000",
                    "updated": "2009-06-11T03:19:08.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/40796",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=thawkins",
                        "name": "thawkins",
                        "displayName": "Tim Hawkins",
                        "active": true
                    },
                    "body": "there is an alternative way to handle this\r\n\r\n1. create a tag record as a key in memcache and set its value (version) initially to '0'\r\n\r\n2. for each tagged key you store\/retrieve in memcache, get the value of the tag to create a key extension of something like [tagname]_[version]_ ........ . \r\n\r\n3. if you want to invalidate all the keys for a particular tag, just increment the value stored in its tag value. \r\n\r\nit means that you have to access memcache to get the tag version number for each tagged key read or write, \r\nbut since its just a single integer it should be very fast. it only needs to be read once for each tag, so reads\/writes of keys in the same tag could \r\nuse a locally cached version number. \r\n\r\nexample:   if you create a tag called \"fred\" and store a key called \"smith\" against it, the key generated would be fred=>0 for the tag and fred_0_smith=>data for the key\/value\r\n\r\nincrementing the key would result in reads against fred_1_smith which would be the same as invalidating the \"smith\" key and all others associated with that tag. \r\n\r\nUnused values would eventually evict from memcache by lru action. You may have to take special action to stop the tag records from evicting. \r\n\r\n\r\n",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=thawkins",
                        "name": "thawkins",
                        "displayName": "Tim Hawkins",
                        "active": true
                    },
                    "created": "2010-05-30T23:47:57.000+0000",
                    "updated": "2010-05-30T23:47:57.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/44551",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ccorliss",
                        "name": "ccorliss",
                        "displayName": "Curtis Corliss",
                        "active": true
                    },
                    "body": "This proposal also has issues with write concurrency.  \r\n\r\nie:\r\n2 threads are saving at the same time and get the current value of the MyTagArrayCacheKey array.\r\nEach thread adds tag=>id entries to the array.\r\nThread 1 writes the modified MyTagArrayCacheKey array, then thread 2 writes its modified MyTagArrayCacheKey array.\r\nMyTagArrayCacheKey does not have tag entries from thread 1.",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ccorliss",
                        "name": "ccorliss",
                        "displayName": "Curtis Corliss",
                        "active": true
                    },
                    "created": "2011-02-23T14:07:06.000+0000",
                    "updated": "2011-02-23T14:07:06.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/46949",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=jskarpet",
                        "name": "jskarpet",
                        "displayName": "jon",
                        "active": true
                    },
                    "body": "What about the memcached-tag project?",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=jskarpet",
                        "name": "jskarpet",
                        "displayName": "jon",
                        "active": true
                    },
                    "created": "2011-06-01T13:48:39.000+0000",
                    "updated": "2011-06-01T13:48:39.000+0000"
                }
            ]
        }
    },
    "transitions": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-4253\/transitions"
}