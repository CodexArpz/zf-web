{
    "expand": "html",
    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-3402",
    "key": "ZF-3402",
    "fields": {
        "summary": {
            "name": "summary",
            "type": "java.lang.String",
            "value": "Zend_Auth_Adapter_DbTable and unique salt per user"
        },
        "timetracking": {
            "name": "timetracking",
            "type": "com.atlassian.jira.issue.fields.TimeTrackingSystemField"
        },
        "issuetype": {
            "name": "issuetype",
            "type": "com.atlassian.jira.issue.issuetype.IssueType",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issueType\/2",
                "name": "New Feature",
                "subtask": false
            }
        },
        "votes": {
            "name": "votes",
            "type": "com.atlassian.jira.issue.fields.VotesSystemField",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-3402\/votes",
                "votes": 2,
                "hasVoted": false
            }
        },
        "security": {
            "name": "security",
            "type": "com.atlassian.jira.issue.security.IssueSecurityLevel"
        },
        "resolution": {
            "name": "resolution",
            "type": "com.atlassian.jira.issue.resolution.Resolution",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/resolution\/2",
                "name": "Won't Fix"
            }
        },
        "fixVersions": {
            "name": "fixVersions",
            "type": "com.atlassian.jira.project.version.Version",
            "value": [

            ]
        },
        "resolutiondate": {
            "name": "resolutiondate",
            "type": "java.util.Date",
            "value": "2009-07-30T19:21:13.000+0000"
        },
        "reporter": {
            "name": "reporter",
            "type": "com.opensymphony.user.User",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=mikael",
                "name": "mikael",
                "displayName": "Mikael \u00d6sterberg",
                "active": true
            }
        },
        "created": {
            "name": "created",
            "type": "java.util.Date",
            "value": "2008-06-05T18:40:46.000+0000"
        },
        "updated": {
            "name": "updated",
            "type": "java.util.Date",
            "value": "2009-07-30T19:21:13.000+0000"
        },
        "customfield_10041": {
            "name": "Tags",
            "type": "com.atlassian.jira.plugin.system.customfieldtypes:labels",
            "value": [
                "Auth",
                "Hash",
                "Password",
                "Salt",
                "Securety",
                "Zend_Auth",
                "login",
                "md5",
                "sha1",
                "sha2",
                "sha512",
                "whirlpool"
            ]
        },
        "description": {
            "name": "description",
            "type": "java.lang.String",
            "value": "Hi i have notice that i can't use unique salt on every password in the db.\nTo increase security i propose that this get built in to the framework.\n\nCode example.\n$auth = Zend_Registry::get('auth');\n$db = Zend_Registry::get('db');\n$authAdapter = new Zend_Auth_Adapter_DbTable($db, 'users', 'username', 'passwd');\n$authAdapter->setIdentity($_POST[\"user\"]);\n$authAdapter->setCredential($_POST[\"passwd\"]);\n\/\/---\n$authAdapter->setSecurety(Zend_Auth_Securety::Db_Salt_PasswordString); \/\/ Or some thing.\n\/\/---\n$result = $auth->authenticate($authAdapter);\n\nDb string example 1: \"md5:1ff73fddc94ef96b107787b28b5a5c931b3c761b:3ca6f61224c49d95323e9bf2fcfbf296\"\nDb string example 2: \"sha1:0038f5a895ba79c8cf8277c34d8f7a71df5b294e:fa5c0b2db734baed9f94f7031f726f574a7c3e6a\"\nDb string sudu: HashAlgorithm :  Salt : Hash ( Salt + Password )\n\nTo validate a password the framework whod have to:\n# Select user by username from users\n# Split the passwd string by \":\" to get algorithm, salt and the salted password hach. \n# Hashalgorithm(  salt + $_POST[\"passwd\"] )\n# compare if step 3:s result is equal to step 2  \"alted password hach\".\n\nThis enables dynamic salt length and random algorithms. \nDepending on the set password function of your application the dynamic salt length and random algorithm feature are active or not.\n\nParanoid?\nIn my db the salt values is off dynamic length 128 to 255 chars and random algorithms (md5, sha1, sha512 and whirlpool). and autouppdate on passwd string on successful login the password is re salted and same or new algorithm . And a user have 4 tries to login."
        },
        "priority": {
            "name": "priority",
            "type": "com.atlassian.jira.issue.priority.Priority",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/priority\/4",
                "name": "Minor"
            }
        },
        "duedate": {
            "name": "duedate",
            "type": "java.util.Date"
        },
        "customfield_10022": {
            "name": "Fix Version Priority",
            "type": "com.atlassian.jira.plugin.system.customfieldtypes:select"
        },
        "watcher": {
            "name": "watcher",
            "type": "watcher",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-3402\/watchers",
                "isWatching": false,
                "watchCount": 4
            }
        },
        "worklog": {
            "name": "worklog",
            "type": "worklog",
            "value": [

            ]
        },
        "status": {
            "name": "status",
            "type": "com.atlassian.jira.issue.status.Status",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/status\/6",
                "name": "Closed"
            }
        },
        "labels": {
            "name": "labels",
            "type": "com.atlassian.jira.issue.label.Label",
            "value": [

            ]
        },
        "assignee": {
            "name": "assignee",
            "type": "com.opensymphony.user.User",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ralph",
                "name": "ralph",
                "displayName": "Ralph Schindler",
                "active": true
            }
        },
        "links": {
            "name": "links",
            "type": "issuelinks",
            "value": [

            ]
        },
        "attachment": {
            "name": "attachment",
            "type": "attachment",
            "value": [

            ]
        },
        "sub-tasks": {
            "name": "sub-tasks",
            "type": "issuelinks",
            "value": [

            ]
        },
        "versions": {
            "name": "versions",
            "type": "com.atlassian.jira.project.version.Version",
            "value": [

            ]
        },
        "project": {
            "name": "project",
            "type": "com.atlassian.jira.project.Project",
            "value": {
                "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/project\/ZF",
                "key": "ZF",
                "name": "Zend Framework",
                "roles": {

                }
            }
        },
        "components": {
            "name": "components",
            "type": "com.atlassian.jira.bc.project.component.ProjectComponent",
            "value": [
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/component\/10084",
                    "id": 10084,
                    "name": "Zend_Auth",
                    "description": "A abstraction for various concrete web application authentication implementations.",
                    "isAssigneeTypeValid": false
                }
            ]
        },
        "comment": {
            "name": "comment",
            "type": "com.atlassian.jira.issue.fields.CommentSystemField",
            "value": [
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/22152",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=mikael",
                        "name": "mikael",
                        "displayName": "Mikael \u00d6sterberg",
                        "active": true
                    },
                    "body": "Zend_Acl to Zend_Auth",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=mikael",
                        "name": "mikael",
                        "displayName": "Mikael \u00d6sterberg",
                        "active": true
                    },
                    "created": "2008-06-05T18:42:48.000+0000",
                    "updated": "2008-06-05T18:42:48.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/22170",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=chriskite",
                        "name": "chriskite",
                        "displayName": "Chris Kite",
                        "active": true
                    },
                    "body": "I agree that a per-user salt would be a useful feature, but I don't think we need dynamic salt lengths or random hash algorithms.\n\nThe salt is useful to prevent precomputation of the possible password hashes by the attacker, so having a dynamic salt length does not increase security (he has to compute just as many salted hashes either way). Choosing the hash algorithm randomly from those 4 only increases the computational difficulty of the precomputation attack by a factor of 4. You might just as well add an extra 2 bits to your salt.\n\nAlso, 128 characters seems excessive for a salt. Unix, for example, uses 12 bits (2 chars). ",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=chriskite",
                        "name": "chriskite",
                        "displayName": "Chris Kite",
                        "active": true
                    },
                    "created": "2008-06-06T13:50:20.000+0000",
                    "updated": "2008-06-06T13:50:20.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/28120",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ralph",
                        "name": "ralph",
                        "displayName": "Ralph Schindler",
                        "active": true
                    },
                    "body": "I am inclined to close this issue.  This use case is already possible, and is documented in the manual.\n\nhttp:\/\/framework.zend.com\/manual\/en\/zend.auth.adapter.dbtable.html\n\nPlease explain reasoning for keeping this open, or providing some kind of idea as per an implementation that you think should be part of Zend_Auth_Adapter_DbTable.",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ralph",
                        "name": "ralph",
                        "displayName": "Ralph Schindler",
                        "active": true
                    },
                    "created": "2009-01-12T09:53:39.000+0000",
                    "updated": "2009-01-12T09:53:39.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/28993",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=adriaan",
                        "name": "adriaan",
                        "displayName": "Adriaan Graas",
                        "active": true
                    },
                    "body": "Reason for keeping this open (from my side) is that dynamic salts are then dependent anymore, whatever kind of database system you use.\nI would like to use special treatment but its not possible with SHA2.",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=adriaan",
                        "name": "adriaan",
                        "displayName": "Adriaan Graas",
                        "active": true
                    },
                    "created": "2009-02-21T11:47:35.000+0000",
                    "updated": "2009-02-21T11:47:35.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/29063",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ralph",
                        "name": "ralph",
                        "displayName": "Ralph Schindler",
                        "active": true
                    },
                    "body": "The problem is that there is no common pattern for salting a database.  Ultimately, the Zend_Auth_Adapter_DbTable has been refactored to facilitate extending it so that this kind of scenario is possible.  The only addition I could think that would be possible is the ability to add a setCredentialTreatmentCallback method so that you can pass in a php funciton to handle the \"salting\" but even then, that approach seems somewhat limited.\n\nWhat do you mean by \" I would like to use special treatment but its not possible with SHA2. \" ?\n\n(Also keep in mind, this adapter cannot be any one database specific .. like only for MySQL)",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ralph",
                        "name": "ralph",
                        "displayName": "Ralph Schindler",
                        "active": true
                    },
                    "created": "2009-02-24T11:27:38.000+0000",
                    "updated": "2009-02-24T11:27:38.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/29064",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=adriaan",
                        "name": "adriaan",
                        "displayName": "Adriaan Graas",
                        "active": true
                    },
                    "body": "Sorry for being a bit unclear, here comes my explaination.\n\nSay you want a unique per user, that is saved in the database, in a special column called 'salt', and you have a MD5 password hash (with the salt applied to the password ofcourse) in the column 'password'.\n\nThe current option is to use a function that's build in your database, thus thats some database specific thing. For example MySQL supports the MD5() function, which makes it possible to use MD5(CONCAT(salt,?)) which would apply the salt from the 'salt' column to the inputted password. So for MD5 and MySQL, things are allright.\n\nUnfortunately a lot of hashing algorithms are not supported by MySQL and other databases. Ofcourse it's possible to get the salt from the database, apply it to the password, and then feed it to Zend_Auth, but thats not really the way to go, imho.\n\nIf I wanted to use SHA2 hashes with salts, this would be the only option. Therefore I think it should be possible to supply the hashing algorithm, or algorithm function to Zend_Auth. With that you need also to supply the database column that contains the salt (or, as Mikael suggested, salt:hash in one column), and the way the salt should be applied to the password f.e. salt + password + salt, or salt + password, or something different.\n\nThere is indeed a problem that there is no common pattern for salting a database. The solution is a bit annoying but is just to have a function which you can give as parameters the column name and a regex -or something similar- to get the salt. Then you can use a credentialTreatment-like to have a formatted string fed to Zend_Auth, which tells you where the salt should be applied to the password.\n\nI hope this makes it a bit clear and if you have any questions or if im wrong please let me know! Thanks and keep up the good work.",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=adriaan",
                        "name": "adriaan",
                        "displayName": "Adriaan Graas",
                        "active": true
                    },
                    "created": "2009-02-24T13:14:38.000+0000",
                    "updated": "2009-02-24T13:14:38.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/29065",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=matthew",
                        "name": "matthew",
                        "displayName": "Matthew Weier O'Phinney",
                        "active": true
                    },
                    "body": "Honestly, I think this sort of pattern requires a different adapter. It could certainly extend the standard DbTable adapter, but the suggestions you're making are adding a fair amount of complexity to the API that many users simply won't need or use. If they find themselves needing it, they can switch adapters.\n\nAs such, could you please create a proposal for the new adapter? From what I'm reading here, there are several potential approaches, and it would be good to get community feedback to see if additional approaches could also be captured in the requirements.",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=matthew",
                        "name": "matthew",
                        "displayName": "Matthew Weier O'Phinney",
                        "active": true
                    },
                    "created": "2009-02-24T14:44:00.000+0000",
                    "updated": "2009-02-24T14:44:00.000+0000"
                },
                {
                    "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/comment\/33090",
                    "author": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ralph",
                        "name": "ralph",
                        "displayName": "Ralph Schindler",
                        "active": true
                    },
                    "body": "The requested feature is beyond a simple feature request for an existing component.  Salting a row is possible currently and demonstrated in the manual via the databases built-in function set.  Anything beyond what is currently supported should be proposed via the proposal process as it is far more complex than anything that would be covered by this jira- based feature request.\n\n-ralph",
                    "updateAuthor": {
                        "self": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/user?username=ralph",
                        "name": "ralph",
                        "displayName": "Ralph Schindler",
                        "active": true
                    },
                    "created": "2009-07-30T19:21:13.000+0000",
                    "updated": "2009-07-30T19:21:13.000+0000"
                }
            ]
        }
    },
    "transitions": "http:\/\/fw02.zend.com\/issues\/rest\/api\/latest\/issue\/ZF-3402\/transitions"
}