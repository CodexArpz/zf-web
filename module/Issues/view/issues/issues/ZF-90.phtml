<h2>ZF-90: memory segmen storage provider</h2>

<dl class="metadata">
    <dt>Issue Type:</dt>
    <dd>Improvement</dd>

    <dt>Created:</dt>
    <dd>2006-06-21T10:47:54.000+0000</dd>

    <dt>Last Updated:</dt>
    <dd>2009-11-07T08:46:08.000+0000</dd>

    <dt>Status:</dt>
    <dd>Resolved</dd>

    <dt>Fix version(s):</dt>
    <dd><ul>        <li>0.8.0 (21/Feb/07)</li>
    </ul></dd>

    <dt>Reporter:</dt>
    <dd>
                Alexander Veremyev (alexander)
            </dd>

    <dt>Assignee:</dt>
    <dd>
                Alexander Veremyev (alexander)
            </dd>

    <dt>Tags:</dt>
    <dd><ul>        <li>Zend_Search_Lucene</li>
        </ul></dd>

    <dt>Related issues:</dt>
    <dd><ul>
        <li><a href="/issues/browse/ZF-87">ZF-87</a></li>
        </ul></dd>

    <dt>Attachments:</dt>
    <dd><ul>
    </ul></dd>
</dl>

<div class="description">
    <h3>Description</h3>

    <div class="body">
        <p>Zend_Search_Lucene_Storage_Directory_RAM and Zend_Search_Lucene_Storage_File_RAM classes should be added to store segment in memory.
It should improve indexing performance.</p>

    </div>
</div>

<div class="comments">
    <h3>Comments</h3>

    <div class="comment">
        <p class="metadata">Posted by Alexander Veremyev (alexander) on 2006-06-21T10:50:46.000+0000</p> 
        <div class="body">
            <p>In-memory segment creation  is not significant without segment mergin functionality</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Alexander Veremyev (alexander) on 2006-10-20T11:11:09.000+0000</p> 
        <div class="body">
            <p>No, it's Zend_Search issue, which doesn't depends from Zend_Memory.</p>

<p>Zend_Memory goal is to use filesystem (or other backend) as a temporary storage for data, when we don't have enough memory.</p>

<p>memory segmen storage provider is a 'virtual filesystem' in RAM. Goal is to speed up document indexing, which performs a lot of small read/write operations.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Bill Karwin (bkarwin) on 2006-11-13T15:17:38.000+0000</p> 
        <div class="body">
            <p>Changing fix version to 0.6.0.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Alexander Veremyev (alexander) on 2007-01-24T19:50:31.000+0000</p> 
        <div class="body">
            <p>obsolete.</p>

<p>Zend_Search_Lucene uses MaxBufferedDocs option to accumulate documents in memory.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Chris Mattmann (chrismattmann) on 2009-04-24T19:53:44.000+0000</p> 
        <div class="body">
            <p>Hi,</p>

<p>In the case where there is a separate Lucene index, built from e.g., Java Lucene, then wouldn't a Zend_Search_Lucene RAMDirectory that loads that separately created index into memory and then supports querying of it as persisted in RAM significantly speed up the performance of ZSL?</p>

<p>I can see how MaxBufferedDocs affects indexing performance, but how does it affect search performance?</p>

<p>Thanks,
Chris</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Alexander Veremyev (alexander) on 2009-11-06T03:26:18.000+0000</p> 
        <div class="body">
            <p>Chris, I've just got your comment. MaxBufferedDocs doesn't affect search performance. But Java Lucene RAMDirectory implementation also used only during indexing. OS supported RAM disk or OS level file system caching may be used to increase search performance.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Chris Mattmann (chrismattmann) on 2009-11-07T08:46:03.000+0000</p> 
        <div class="body">
            <p>Thanks for your comment, Alexander. Is an OS supported RAM disk or OS level file system caching something that we could implement in Zend_Search_Lucene? I'm willing to help, just point me in the right direction...</p>

        </div>
    </div>
    </div>

