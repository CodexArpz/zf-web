diff -urN trunk/library/Zend/Soap/AutoDiscover.php tomdev/library/Zend/Soap/AutoDiscover.php
--- trunk/library/Zend/Soap/AutoDiscover.php	2008-09-16 17:22:50.000000000 +0200
+++ tomdev/library/Zend/Soap/AutoDiscover.php	2008-09-16 17:28:44.000000000 +0200
@@ -26,12 +26,12 @@
 require_once 'Zend/Server/Abstract.php';
 require_once 'Zend/Uri.php';
 
-/**
- * Zend_Soap_AutoDiscover
- * 
- * @category   Zend
- * @package    Zend_Soap
- */
+/**
+ * Zend_Soap_AutoDiscover
+ * 
+ * @category   Zend
+ * @package    Zend_Soap
+ */
 class Zend_Soap_AutoDiscover extends Zend_Server_Abstract implements Zend_Server_Interface {
     /**
      * @var Zend_Soap_Wsdl
@@ -46,21 +46,21 @@
     /**
      * @var array
      */
-    private $_functions = array();
-
-    /**
-     * @var boolean
-     */
+    private $_functions = array();
+
+    /**
+     * @var boolean
+     */
     private $_extractComplexTypes;
     
     /**
-     * Constructor
-     * 
+     * Constructor
+     * 
      * @param boolean $extractComplexTypes
      */
     public function __construct($extractComplexTypes = true)
     {
-        $this->_reflection = new Zend_Server_Reflection();
+        $this->_reflection = new Zend_Server_Reflection();
         $this->_extractComplexTypes = $extractComplexTypes;
     }
     
@@ -72,8 +72,8 @@
      * @param array $argv Arguments to instantiate the class - Not Used
      */
     public function setClass($class, $namespace = '', $argv = null)
-    {
-        $uri = Zend_Uri::factory('http://' . $_SERVER['HTTP_HOST'] . $_SERVER['SCRIPT_NAME']);
+    {
+        $uri = Zend_Uri::factory('http://' . $_SERVER['HTTP_HOST'] . $_SERVER['SCRIPT_NAME']);
 
         $wsdl = new Zend_Soap_Wsdl($class, $uri, $this->_extractComplexTypes);
         
@@ -82,19 +82,19 @@
         
         $wsdl->addSoapBinding($binding, 'rpc');
         $wsdl->addService($class . 'Service', $class . 'Port', 'tns:' . $class . 'Binding', $uri);
-        foreach ($this->_reflection->reflectClass($class)->getMethods() as $method) {
-            /* <wsdl:portType>'s */
-            $portOperation = $wsdl->addPortOperation($port, $method->getName(), 'tns:' .$method->getName(). 'Request', 'tns:' .$method->getName(). 'Response');
-            $desc = $method->getDescription();
-            if (strlen($desc) > 0) {
-                /** @todo check, what should be done for portoperation documentation */
-                //$wsdl->addDocumentation($portOperation, $desc);
-            }
-            /* </wsdl:portType>'s */
-            
-            $this->_functions[] = $method->getName();
-
-            foreach ($method->getPrototypes() as $prototype) {
+        foreach ($this->_reflection->reflectClass($class)->getMethods() as $method) {
+            /* <wsdl:portType>'s */
+            $portOperation = $wsdl->addPortOperation($port, $method->getName(), 'tns:' .$method->getName(). 'Request', 'tns:' .$method->getName(). 'Response');
+            $desc = $method->getDescription();
+            if (strlen($desc) > 0) {
+                /** @todo check, what should be done for portoperation documentation */
+                //$wsdl->addDocumentation($portOperation, $desc);
+            }
+            /* </wsdl:portType>'s */
+            
+            $this->_functions[] = $method->getName();
+
+            foreach ($method->getPrototypes() as $prototype) {
                 $args = array();
                 foreach ($prototype->getParameters() as $param) {
                     $args[$param->getName()] = $wsdl->getType($param->getType());
@@ -106,12 +106,12 @@
                 if ($prototype->getReturnType() != "void") {
                     $message = $wsdl->addMessage($method->getName() . 'Response', array($method->getName() . 'Return' => $wsdl->getType($prototype->getReturnType())));
                 }
-
+
                 /* <wsdl:binding>'s */
                 $operation = $wsdl->addBindingOperation($binding, $method->getName(),  array('use' => 'encoded', 'encodingStyle' => "http://schemas.xmlsoap.org/soap/encoding/"), array('use' => 'encoded', 'encodingStyle' => "http://schemas.xmlsoap.org/soap/encoding/"));
                 $wsdl->addSoapOperation($binding, $uri->getUri() . '#' .$method->getName());
                 /* </wsdl:binding>'s */
-            }
+            }
         }
         $this->_wsdl = $wsdl;
     }
@@ -248,14 +248,14 @@
      * @return string
      */
     public function getType($type)
-    {
-        if (!($this->_wsdl instanceof Zend_Soap_Wsdl)) {
-            /** @todo Exception throwing may be more correct */
-
-            // WSDL is not defined yet, so we can't recognize type in context of current service
-            return '';
-        } else {
-            return $this->_wsdl->getType($type);
+    {
+        if (!($this->_wsdl instanceof Zend_Soap_Wsdl)) {
+            /** @todo Exception throwing may be more correct */
+
+            // WSDL is not defined yet, so we can't recognize type in context of current service
+            return '';
+        } else {
+            return $this->_wsdl->getType($type);
         }
     }
 }
diff -urN trunk/library/Zend/Soap/Client.php tomdev/library/Zend/Soap/Client.php
--- trunk/library/Zend/Soap/Client.php	2008-09-16 17:22:50.000000000 +0200
+++ tomdev/library/Zend/Soap/Client.php	2008-09-16 17:28:44.000000000 +0200
@@ -19,17 +19,17 @@
  */
 
 /** Zend_Soap_Client_Exception */
-require_once 'Zend/Soap/Client/Exception.php';
-
-/** Zend_Soap_Server */
-require_once 'Zend/Soap/Server.php';
-
-/** Zend_Soap_Client_Local */
-require_once 'Zend/Soap/Client/Local.php';
+require_once 'Zend/Soap/Client/Exception.php';
+
+/** Zend_Soap_Server */
+require_once 'Zend/Soap/Server.php';
+
+/** Zend_Soap_Client_Local */
+require_once 'Zend/Soap/Client/Local.php';
 
 /** Zend_Soap_Client_Common */
 require_once 'Zend/Soap/Client/Common.php';
-
+
 
 /**
  * Zend_Soap_Client
@@ -40,71 +40,71 @@
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
 class Zend_Soap_Client
-{
-    /**
-     * Encoding
-     * @var string
-     */
-    protected $_encoding = 'UTF-8';
-
-    /**
-     * Array of SOAP type => PHP class pairings for handling return/incoming values
-     * @var array
-     */
-    protected $_classmap = null;
-
-    /**
-     * Registered fault exceptions
-     * @var array
-     */
-    protected $_faultExceptions = array();
-
-    /**
-     * SOAP version to use; SOAP_1_2 by default, to allow processing of headers
-     * @var int
-     */
-    protected $_soapVersion = SOAP_1_2;
-
-    /** Set of other SoapClient options */
-    protected $_uri                 = null;
-    protected $_location            = null;
-    protected $_style               = null;
-    protected $_use                 = null;
-    protected $_login               = null;
-    protected $_password            = null;
-    protected $_proxy_host          = null;
-    protected $_proxy_port          = null;
-    protected $_proxy_login         = null;
-    protected $_proxy_password      = null;
-    protected $_local_cert          = null;
-    protected $_passphrase          = null;
-    protected $_compression         = null;
-    protected $_connection_timeout  = null;
-
-    /**
-     * WSDL used to access server
-     * It also defines Zend_Soap_Client working mode (WSDL vs non-WSDL)
-     *
-     * @var string
-     */
-    protected $_wsdl = null;
-
-    /**
-     * SoapClient object
-     *
-     * @var SoapClient
-     */
-    protected $_soapClient;
+{
+    /**
+     * Encoding
+     * @var string
+     */
+    protected $_encoding = 'UTF-8';
+
+    /**
+     * Array of SOAP type => PHP class pairings for handling return/incoming values
+     * @var array
+     */
+    protected $_classmap = null;
+
+    /**
+     * Registered fault exceptions
+     * @var array
+     */
+    protected $_faultExceptions = array();
+
+    /**
+     * SOAP version to use; SOAP_1_2 by default, to allow processing of headers
+     * @var int
+     */
+    protected $_soapVersion = SOAP_1_2;
+
+    /** Set of other SoapClient options */
+    protected $_uri                 = null;
+    protected $_location            = null;
+    protected $_style               = null;
+    protected $_use                 = null;
+    protected $_login               = null;
+    protected $_password            = null;
+    protected $_proxy_host          = null;
+    protected $_proxy_port          = null;
+    protected $_proxy_login         = null;
+    protected $_proxy_password      = null;
+    protected $_local_cert          = null;
+    protected $_passphrase          = null;
+    protected $_compression         = null;
+    protected $_connection_timeout  = null;
+
+    /**
+     * WSDL used to access server
+     * It also defines Zend_Soap_Client working mode (WSDL vs non-WSDL)
+     *
+     * @var string
+     */
+    protected $_wsdl = null;
+
+    /**
+     * SoapClient object
+     *
+     * @var SoapClient
+     */
+    protected $_soapClient;
 
     /**
      * Last invoked method
      *
      * @var string
      */
-    protected $_lastMethod = '';
+    protected $_lastMethod = '';
 
     /**
-     * Constructor
+     * Constructor
      *
      * @param string $wsdl
      * @param array $options
@@ -114,15 +114,15 @@
         if (!extension_loaded('soap')) {
             throw new Zend_Soap_Client_Exception('SOAP extension is not loaded.');
         }
-
-        if ($wsdl !== null) {
-            $this->setWsdl($wsdl);
-        }
-        if ($options !== null) {
-            $this->setOptions($options);
-        }
+
+        if ($wsdl !== null) {
+            $this->setWsdl($wsdl);
+        }
+        if ($options !== null) {
+            $this->setOptions($options);
+        }
     }
-
+
     /**
      * Set wsdl
      *
@@ -130,231 +130,231 @@
      * @return Zend_Soap_Client
      */
     public function setWsdl($wsdl)
-    {
-        $this->_wsdl = $wsdl;
-        $this->_soapClient = null;
-
-        return $this;
-    }
-
-    /**
-     * Get wsdl
-     *
-     * @return string
-     */
-    public function getWsdl()
-    {
-        return $this->_wsdl;
-    }
-
-    /**
-     * Set Options
-     *
-     * Allows setting options as an associative array of option => value pairs.
-     *
-     * @param  array $options
-     * @return Zend_Soap_Client
-     * @throws Zend_SoapClient_Exception
-     */
-    public function setOptions(array $options)
-    {
-        foreach ($options as $key => $value) {
-            switch ($key) {
-                case 'classmap':
-                case 'classMap':
-                    $this->setClassmap($value);
-                    break;
-                case 'encoding':
-                    $this->setEncoding($value);
-                    break;
-                case 'soapVersion':
-                case 'soap_version':
-                    $this->setSoapVersion($value);
-                    break;
-                case 'wsdl':
-                    $this->setWsdl($value);
-                    break;
-                case 'uri':
-                    $this->setUri($value);
-                    break;
-                case 'location':
-                    $this->setLocation($value);
-                    break;
-                case 'style':
-                    $this->setStyle($value);
-                    break;
-                case 'use':
-                    $this->setEncodingMethod($value);
-                    break;
-                case 'login':
-                    $this->setHttpLogin($value);
-                    break;
-                case 'password':
-                    $this->setHttpPassword($value);
-                    break;
-                case 'proxy_host':
-                    $this->setProxyHost($value);
-                    break;
-                case 'proxy_port':
-                    $this->setProxyPort($value);
-                    break;
-                case 'proxy_login':
-                    $this->setProxyLogin($value);
-                    break;
-                case 'proxy_password':
-                    $this->setProxyPassword($value);
-                    break;
-                case 'local_cert':
-                    $this->setHttpsCertificate($value);
-                    break;
-                case 'passphrase':
-                    $this->setHttpsCertPassphrase($value);
-                    break;
-                case 'compression':
-                    $this->setCompressionOptions($value);
-                    break;
-
-                // Not used now
-                // case 'connection_timeout':
-                //     $this->_connection_timeout = $value;
-                //    break;
-
-                default:
-                    throw new Zend_Soap_Client_Exception('Unknown SOAP client option');
-                    break;
-            }
-        }
-
-        return $this;
-    }
-
-    /**
-     * Return array of options suitable for using with SoapClient constructor
-     *
-     * @return array
-     */
-    public function getOptions()
-    {
+    {
+        $this->_wsdl = $wsdl;
+        $this->_soapClient = null;
+
+        return $this;
+    }
+
+    /**
+     * Get wsdl
+     *
+     * @return string
+     */
+    public function getWsdl()
+    {
+        return $this->_wsdl;
+    }
+
+    /**
+     * Set Options
+     *
+     * Allows setting options as an associative array of option => value pairs.
+     *
+     * @param  array $options
+     * @return Zend_Soap_Client
+     * @throws Zend_SoapClient_Exception
+     */
+    public function setOptions(array $options)
+    {
+        foreach ($options as $key => $value) {
+            switch ($key) {
+                case 'classmap':
+                case 'classMap':
+                    $this->setClassmap($value);
+                    break;
+                case 'encoding':
+                    $this->setEncoding($value);
+                    break;
+                case 'soapVersion':
+                case 'soap_version':
+                    $this->setSoapVersion($value);
+                    break;
+                case 'wsdl':
+                    $this->setWsdl($value);
+                    break;
+                case 'uri':
+                    $this->setUri($value);
+                    break;
+                case 'location':
+                    $this->setLocation($value);
+                    break;
+                case 'style':
+                    $this->setStyle($value);
+                    break;
+                case 'use':
+                    $this->setEncodingMethod($value);
+                    break;
+                case 'login':
+                    $this->setHttpLogin($value);
+                    break;
+                case 'password':
+                    $this->setHttpPassword($value);
+                    break;
+                case 'proxy_host':
+                    $this->setProxyHost($value);
+                    break;
+                case 'proxy_port':
+                    $this->setProxyPort($value);
+                    break;
+                case 'proxy_login':
+                    $this->setProxyLogin($value);
+                    break;
+                case 'proxy_password':
+                    $this->setProxyPassword($value);
+                    break;
+                case 'local_cert':
+                    $this->setHttpsCertificate($value);
+                    break;
+                case 'passphrase':
+                    $this->setHttpsCertPassphrase($value);
+                    break;
+                case 'compression':
+                    $this->setCompressionOptions($value);
+                    break;
+
+                // Not used now
+                // case 'connection_timeout':
+                //     $this->_connection_timeout = $value;
+                //    break;
+
+                default:
+                    throw new Zend_Soap_Client_Exception('Unknown SOAP client option');
+                    break;
+            }
+        }
+
+        return $this;
+    }
+
+    /**
+     * Return array of options suitable for using with SoapClient constructor
+     *
+     * @return array
+     */
+    public function getOptions()
+    {
         $options = array();
 
-        $options['classmap']       = $this->getClassmap();
-        $options['encoding']       = $this->getEncoding();
-        $options['soap_version']   = $this->getSoapVersion();
-        $options['wsdl']           = $this->getWsdl();
-        $options['uri']            = $this->getUri();
-        $options['location']       = $this->getLocation();
-        $options['style']          = $this->getStyle();
-        $options['use']            = $this->getEncodingMethod();
-        $options['login']          = $this->getHttpLogin();
-        $options['password']       = $this->getHttpPassword();
-        $options['proxy_host']     = $this->getProxyHost();
-        $options['proxy_port']     = $this->getProxyPort();
-        $options['proxy_login']    = $this->getProxyLogin();
-        $options['proxy_password'] = $this->getProxyPassword();
-        $options['local_cert']     = $this->getHttpsCertificate();
-        $options['passphrase']     = $this->getHttpsCertPassphrase();
-        $options['compression']    = $this->getCompressionOptions();
-//        $options['connection_timeout'] = $this->_connection_timeout;
+        $options['classmap']       = $this->getClassmap();
+        $options['encoding']       = $this->getEncoding();
+        $options['soap_version']   = $this->getSoapVersion();
+        $options['wsdl']           = $this->getWsdl();
+        $options['uri']            = $this->getUri();
+        $options['location']       = $this->getLocation();
+        $options['style']          = $this->getStyle();
+        $options['use']            = $this->getEncodingMethod();
+        $options['login']          = $this->getHttpLogin();
+        $options['password']       = $this->getHttpPassword();
+        $options['proxy_host']     = $this->getProxyHost();
+        $options['proxy_port']     = $this->getProxyPort();
+        $options['proxy_login']    = $this->getProxyLogin();
+        $options['proxy_password'] = $this->getProxyPassword();
+        $options['local_cert']     = $this->getHttpsCertificate();
+        $options['passphrase']     = $this->getHttpsCertPassphrase();
+        $options['compression']    = $this->getCompressionOptions();
+//        $options['connection_timeout'] = $this->_connection_timeout;
 
         foreach ($options as $key => $value) {
             if ($value == null) {
                 unset($options[$key]);
             }
         }
-
-        return $options;
-    }
-
-    /**
-     * Set SOAP version
-     *
-     * @param  int $version One of the SOAP_1_1 or SOAP_1_2 constants
-     * @return Zend_Soap_Client
-     * @throws Zend_Soap_Client_Exception with invalid soap version argument
-     */
-    public function setSoapVersion($version)
-    {
-        if (!in_array($version, array(SOAP_1_1, SOAP_1_2))) {
-            throw new Zend_Soap_Client_Exception('Invalid soap version specified. Use SOAP_1_1 or SOAP_1_2 constants.');
-        }
+
+        return $options;
+    }
+
+    /**
+     * Set SOAP version
+     *
+     * @param  int $version One of the SOAP_1_1 or SOAP_1_2 constants
+     * @return Zend_Soap_Client
+     * @throws Zend_Soap_Client_Exception with invalid soap version argument
+     */
+    public function setSoapVersion($version)
+    {
+        if (!in_array($version, array(SOAP_1_1, SOAP_1_2))) {
+            throw new Zend_Soap_Client_Exception('Invalid soap version specified. Use SOAP_1_1 or SOAP_1_2 constants.');
+        }
         $this->_soapVersion = $version;
 
         $this->_soapClient = null;
-
-        return $this;
-    }
-
-    /**
-     * Get SOAP version
-     *
-     * @return int
-     */
-    public function getSoapVersion()
-    {
-        return $this->_soapVersion;
-    }
-
-    /**
-     * Set classmap
-     *
-     * @param  array $classmap
-     * @return Zend_Soap_Client
-     * @throws Zend_Soap_Client_Exception for any invalid class in the class map
-     */
-    public function setClassmap(array $classmap)
-    {
-        foreach ($classmap as $type => $class) {
-            if (!class_exists($class)) {
-                throw new Zend_Soap_Client_Exception('Invalid class in class map');
-            }
-        }
-
+
+        return $this;
+    }
+
+    /**
+     * Get SOAP version
+     *
+     * @return int
+     */
+    public function getSoapVersion()
+    {
+        return $this->_soapVersion;
+    }
+
+    /**
+     * Set classmap
+     *
+     * @param  array $classmap
+     * @return Zend_Soap_Client
+     * @throws Zend_Soap_Client_Exception for any invalid class in the class map
+     */
+    public function setClassmap(array $classmap)
+    {
+        foreach ($classmap as $type => $class) {
+            if (!class_exists($class)) {
+                throw new Zend_Soap_Client_Exception('Invalid class in class map');
+            }
+        }
+
         $this->_classmap = $classmap;
 
         $this->_soapClient = null;
-
-        return $this;
-    }
-
-    /**
-     * Retrieve classmap
-     *
-     * @return mixed
-     */
-    public function getClassmap()
-    {
-        return $this->_classmap;
-    }
-
-    /**
-     * Set encoding
-     *
-     * @param  string $encoding
-     * @return Zend_Soap_Client
-     * @throws Zend_Soap_Client_Exception with invalid encoding argument
-     */
-    public function setEncoding($encoding)
-    {
-        if (!is_string($encoding)) {
-            throw new Zend_Soap_Client_Exception('Invalid encoding specified');
-        }
-
+
+        return $this;
+    }
+
+    /**
+     * Retrieve classmap
+     *
+     * @return mixed
+     */
+    public function getClassmap()
+    {
+        return $this->_classmap;
+    }
+
+    /**
+     * Set encoding
+     *
+     * @param  string $encoding
+     * @return Zend_Soap_Client
+     * @throws Zend_Soap_Client_Exception with invalid encoding argument
+     */
+    public function setEncoding($encoding)
+    {
+        if (!is_string($encoding)) {
+            throw new Zend_Soap_Client_Exception('Invalid encoding specified');
+        }
+
         $this->_encoding = $encoding;
-
+
         $this->_soapClient = null;
 
-        return $this;
-    }
-
-    /**
-     * Get encoding
-     *
-     * @return string
-     */
-    public function getEncoding()
-    {
-        return $this->_encoding;
-    }
+        return $this;
+    }
+
+    /**
+     * Get encoding
+     *
+     * @return string
+     */
+    public function getEncoding()
+    {
+        return $this->_encoding;
+    }
 
     /**
      * Check for valid URN
@@ -401,7 +401,7 @@
     {
         return $this->_uri;
     }
-
+
     /**
      * Set Location
      *
@@ -721,33 +721,33 @@
         return $this->_proxy_password;
     }
 
-    /**
-     * Retrieve request XML
-     *
-     * @return string
-     */
-    public function getLastRequest()
-    {
-        if ($this->_soapClient !== null) {
-            return $this->_soapClient->__getLastRequest();
-        }
-
-        return '';
-    }
-
-    /**
-     * Get response XML
-     *
-     * @return string
-     */
-    public function getLastResponse()
-    {
-        if ($this->_soapClient !== null) {
-            return $this->_soapClient->__getLastResponse();
-        }
-
-        return '';
-    }
+    /**
+     * Retrieve request XML
+     *
+     * @return string
+     */
+    public function getLastRequest()
+    {
+        if ($this->_soapClient !== null) {
+            return $this->_soapClient->__getLastRequest();
+        }
+
+        return '';
+    }
+
+    /**
+     * Get response XML
+     *
+     * @return string
+     */
+    public function getLastResponse()
+    {
+        if ($this->_soapClient !== null) {
+            return $this->_soapClient->__getLastResponse();
+        }
+
+        return '';
+    }
 
     /**
      * Retrieve request headers
@@ -776,7 +776,7 @@
 
         return '';
     }
-
+
     /**
      * Retrieve last invoked method
      *
@@ -810,37 +810,37 @@
             return call_user_func(array($client,'SoapClient::__doRequest'), $request, $location, $action, $version, $one_way);
         }
     }
-
-    /**
-     * Initialize SOAP Client object
-     *
-     * @throws Zend_Soap_Client_Exception
-     */
-    protected function _initSoapClientObject()
-    {
-        $wsdl = $this->getWsdl();
-        $options = array_merge($this->getOptions(), array('trace' => true));
-
-
-        if ($wsdl == null) {
-            if (!isset($options['location'])) {
-                throw new Zend_Soap_Client_Exception('\'location\' parameter is required in non-WSDL mode.');
-            }
-            if (!isset($options['uri'])) {
-                throw new Zend_Soap_Client_Exception('\'uri\' parameter is required in non-WSDL mode.');
-            }
-        } else {
-            if (isset($options['use'])) {
-                throw new Zend_Soap_Client_Exception('\'use\' parameter only works in non-WSDL mode.');
-            }
-            if (isset($options['style'])) {
-                throw new Zend_Soap_Client_Exception('\'style\' parameter only works in non-WSDL mode.');
-            }
-        }
-        unset($options['wsdl']);
-
+
+    /**
+     * Initialize SOAP Client object
+     *
+     * @throws Zend_Soap_Client_Exception
+     */
+    protected function _initSoapClientObject()
+    {
+        $wsdl = $this->getWsdl();
+        $options = array_merge($this->getOptions(), array('trace' => true));
+
+
+        if ($wsdl == null) {
+            if (!isset($options['location'])) {
+                throw new Zend_Soap_Client_Exception('\'location\' parameter is required in non-WSDL mode.');
+            }
+            if (!isset($options['uri'])) {
+                throw new Zend_Soap_Client_Exception('\'uri\' parameter is required in non-WSDL mode.');
+            }
+        } else {
+            if (isset($options['use'])) {
+                throw new Zend_Soap_Client_Exception('\'use\' parameter only works in non-WSDL mode.');
+            }
+            if (isset($options['style'])) {
+                throw new Zend_Soap_Client_Exception('\'style\' parameter only works in non-WSDL mode.');
+            }
+        }
+        unset($options['wsdl']);
+
         $this->_soapClient = new Zend_Soap_Client_Common(array($this, '_doRequest'), $wsdl, $options);
-    }
+    }
 
 
     /**
@@ -868,45 +868,45 @@
         // Do nothing
         return $result;
     }
-
+
     /**
      * Perform a SOAP call
-     *
-     * @param string $name
+     *
+     * @param string $name
      * @param array  $arguments
-     * @return mixed
+     * @return mixed
      */
     public function __call($name, $arguments)
-    {
-        if ($this->_soapClient == null) {
-            $this->_initSoapClientObject();
-        }
+    {
+        if ($this->_soapClient == null) {
+            $this->_initSoapClientObject();
+        }
 
         $this->_lastMethod = $name; 
         
         $result = call_user_func_array(array($this->_soapClient, $name), $this->_preProcessArguments($arguments));
-
-        return $this->_preProcessResult($result);
+
+        return $this->_preProcessResult($result);
     }
 
-
+
     /**
      * Return a list of available functions
      *
      * @return array
-     * @throws Zend_Soap_Client_Exception
+     * @throws Zend_Soap_Client_Exception
      */
     public function getFunctions()
-    {
-        if ($this->getWsdl() == null) {
-            throw new Zend_Soap_Client_Exception('\'getFunctions\' method is available only in WSDL mode.');
-        }
-
-        if ($this->_soapClient == null) {
-            $this->_initSoapClientObject();
-        }
-
-        return $this->_soapClient->__getFunctions();
+    {
+        if ($this->getWsdl() == null) {
+            throw new Zend_Soap_Client_Exception('\'getFunctions\' method is available only in WSDL mode.');
+        }
+
+        if ($this->_soapClient == null) {
+            $this->_initSoapClientObject();
+        }
+
+        return $this->_soapClient->__getFunctions();
     }
 
 
diff -urN trunk/library/Zend/Soap/Wsdl/CodeGenerator.php tomdev/library/Zend/Soap/Wsdl/CodeGenerator.php
--- trunk/library/Zend/Soap/Wsdl/CodeGenerator.php	2008-09-16 17:22:50.000000000 +0200
+++ tomdev/library/Zend/Soap/Wsdl/CodeGenerator.php	2008-09-16 17:28:44.000000000 +0200
@@ -21,12 +21,12 @@
 
 require_once 'Zend/Soap/Wsdl/Parser.php';
 
-/**
- * Zend_Soap_Wsdl_CodeGenerator
- * 
- * @category   Zend
- * @package    Zend_Soap
- */
+/**
+ * Zend_Soap_Wsdl_CodeGenerator
+ * 
+ * @category   Zend
+ * @package    Zend_Soap
+ */
 class Zend_Soap_Wsdl_CodeGenerator {
    
     /**
diff -urN trunk/library/Zend/Soap/Wsdl/Parser/Result.php tomdev/library/Zend/Soap/Wsdl/Parser/Result.php
--- trunk/library/Zend/Soap/Wsdl/Parser/Result.php	2008-09-16 17:22:50.000000000 +0200
+++ tomdev/library/Zend/Soap/Wsdl/Parser/Result.php	2008-09-16 17:28:44.000000000 +0200
@@ -19,12 +19,12 @@
  * @version    $Id: Result.php 9722 2008-06-18 12:36:35Z alexander $
  */
 
-/**
- * Zend_Soap_Wsdl_Parser_Result
- * 
- * @category   Zend
- * @package    Zend_Soap
- */
+/**
+ * Zend_Soap_Wsdl_Parser_Result
+ * 
+ * @category   Zend
+ * @package    Zend_Soap
+ */
 class Zend_Soap_Wsdl_Parser_Result {
     
     public $wsdl_file = '';
diff -urN trunk/library/Zend/Soap/Wsdl/Parser.php tomdev/library/Zend/Soap/Wsdl/Parser.php
--- trunk/library/Zend/Soap/Wsdl/Parser.php	2008-09-16 17:22:50.000000000 +0200
+++ tomdev/library/Zend/Soap/Wsdl/Parser.php	2008-09-16 17:28:44.000000000 +0200
@@ -21,12 +21,12 @@
 
 require_once 'Zend/Soap/Wsdl/Parser/Result.php';
 
-/**
- * Zend_Soap_Wsdl_Parser
- * 
- * @category   Zend
- * @package    Zend_Soap
- */
+/**
+ * Zend_Soap_Wsdl_Parser
+ * 
+ * @category   Zend
+ * @package    Zend_Soap
+ */
 class Zend_Soap_Wsdl_Parser {
     /**
      * @var SimpleXML object for the WSDL document being parsed
diff -urN trunk/library/Zend/Soap/Wsdl.php tomdev/library/Zend/Soap/Wsdl.php
--- trunk/library/Zend/Soap/Wsdl.php	2008-09-16 17:22:50.000000000 +0200
+++ tomdev/library/Zend/Soap/Wsdl.php	2008-09-16 17:28:44.000000000 +0200
@@ -20,14 +20,14 @@
  */
 
 require_once 'Zend/Server/Exception.php';
-
 
-/**
- * Zend_Soap_Wsdl
- *
- * @category   Zend
- * @package    Zend_Soap
- */
+
+/**
+ * Zend_Soap_Wsdl
+ *
+ * @category   Zend
+ * @package    Zend_Soap
+ */
 class Zend_Soap_Wsdl {
     /**
      * @var object DomDocument Instance
@@ -39,45 +39,45 @@
      */
     private $_wsdl;
 
-    /**
-     * @var string URI where the WSDL will be available
-     */
-    private $_uri;
-
-    /**
-     * @var DOMElement
-     */
-    private $_schema = null;
-
-    /**
-     * Types defined on schema
-     *
-     * @var array
-     */
-    private $_includedTypes = array();
-
-    /**
-     * @var boolean
-     */
-    private $_extractComplexTypes;
-
-
+    /**
+     * @var string URI where the WSDL will be available
+     */
+    private $_uri;
+
+    /**
+     * @var DOMElement
+     */
+    private $_schema = null;
+
+    /**
+     * Types defined on schema
+     *
+     * @var array
+     */
+    private $_includedTypes = array();
+
+    /**
+     * @var boolean
+     */
+    private $_extractComplexTypes;
+
+
     /**
      * Constructor
      *
      * @param string  $name Name of the Web Service being Described
      * @param string  $uri URI where the WSDL will be available
-     * @param boolean $extractComplexTypes
+     * @param boolean $extractComplexTypes
      */
     public function __construct($name, $uri, $extractComplexTypes = true)
     {
         if ($uri instanceof Zend_Uri_Http) {
             $uri = $this->_uri = $uri->getUri();
-        }
-
-        /**
-         * @todo change DomDocument object creation from cparsing to construxting using API
-         * It also should authomatically escape $name and $uri values if necessary
+        }
+
+        /**
+         * @todo change DomDocument object creation from cparsing to construxting using API
+         * It also should authomatically escape $name and $uri values if necessary
          */
         $wsdl = "<?xml version='1.0' ?>
                 <definitions name='$name' targetNamespace='$uri'
@@ -91,9 +91,9 @@
             throw new Zend_Server_Exception('Unable to create DomDocument');
         } else {
             $this->_wsdl = $this->_dom->documentElement;
-        }
+        }
 
-        $this->_extractComplexTypes = $extractComplexTypes;
+        $this->_extractComplexTypes = $extractComplexTypes;
     }
 
     /**
@@ -329,8 +329,8 @@
             $node = $this->_dom->documentElement;
         } else {
             $node = $input_node;
-        }
-
+        }
+
         /** @todo Check if 'documentation' is a correct name for the element (WSDL spec uses 'document') */
         $doc = $this->_dom->createElement('documentation');
         $doc_cdata = $this->_dom->createTextNode($documentation);
@@ -353,7 +353,7 @@
         } elseif ($types instanceof DomNode || $types instanceof DomElement || $types instanceof DomDocumentFragment ) {
             $dom = $this->_dom->importNode($types);
             $this->_wsdl->appendChild($dom);
-        }
+        }
     }
 
     /**
@@ -390,97 +390,97 @@
             return file_put_contents($filename, $this->toXML());
         }
     }
-
-    /**
-     * Returns an XSD Type for the given PHP type
-     *
-     * @param string $type PHP Type to get the XSD type for
-     * @return string
-     */
-    public function getType($type)
-    {
-        switch ($type) {
-            case 'string':
-            case 'str':
-                return 'xsd:string';
-                break;
-            case 'int':
-            case 'integer':
-                return 'xsd:int';
-                break;
-            case 'float':
-            case 'double':
-                return 'xsd:float';
-                break;
-            case 'boolean':
-            case 'bool':
-                return 'xsd:boolean';
-                break;
-            case 'array':
-                return 'soap-enc:Array';
-                break;
-            case 'object':
-                return 'xsd:struct';
-                break;
-            case 'mixed':
-                return 'xsd:anyType';
-                break;
-            case 'void':
-                return '';
-            default:
-                if (class_exists($type) && $this->_extractComplexTypes)
-                    return $this->addComplexType($type);
-                else
-                    return 'xsd:anyType';
-            }
-    }
-
-    /**
-     * Add a {@link http://www.w3.org/TR/wsdl#_types types} data type definition
-     *
-     * @param string $type Name of the class to be specified
-     * @return string XSD Type for the given PHP type
-     */
-    public function addComplexType($type)
-    {
-        if (in_array($type, $this->_includedTypes)) {
-            return "tns:$type";
-        }
-
-        if ($this->_schema === null) {
-            $this->_schema = $this->_dom->createElement('xsd:schema');
-            $this->_schema->setAttribute('targetNamespace', $this->_uri);
-            $types = $this->_dom->createElement('types');
-            $types->appendChild($this->_schema);
-            $this->_wsdl->appendChild($types);
-        }
-
-        $class = new ReflectionClass($type);
-
-        $complexType = $this->_dom->createElement('xsd:complexType');
-        $complexType->setAttribute('name', $type);
-
-        $all = $this->_dom->createElement('xsd:all');
-
-        foreach ($class->getProperties() as $property) {
-            if (preg_match_all('/@var\s+([^\s]+)/m', $property->getDocComment(), $matches)) {
-
-            	/**
-            	 * @todo check if 'xsd:element' must be used here (it may not be compatible with using 'complexType'
-            	 * node for describing other classes used as attribute types for current class
-            	 */
-                $element = $this->_dom->createElement('xsd:element');
-                $element->setAttribute('name', $property->getName());
-                $element->setAttribute('type', $this->getType(trim($matches[1][0])));
-                $all->appendChild($element);
-            }
-        }
-
-        $complexType->appendChild($all);
-        $this->_schema->appendChild($complexType);
-
-        $this->_includedTypes[] = $type;
-
-        return "tns:$type";
-    }
+
+    /**
+     * Returns an XSD Type for the given PHP type
+     *
+     * @param string $type PHP Type to get the XSD type for
+     * @return string
+     */
+    public function getType($type)
+    {
+        switch ($type) {
+            case 'string':
+            case 'str':
+                return 'xsd:string';
+                break;
+            case 'int':
+            case 'integer':
+                return 'xsd:int';
+                break;
+            case 'float':
+            case 'double':
+                return 'xsd:float';
+                break;
+            case 'boolean':
+            case 'bool':
+                return 'xsd:boolean';
+                break;
+            case 'array':
+                return 'soap-enc:Array';
+                break;
+            case 'object':
+                return 'xsd:struct';
+                break;
+            case 'mixed':
+                return 'xsd:anyType';
+                break;
+            case 'void':
+                return '';
+            default:
+                if (class_exists($type) && $this->_extractComplexTypes)
+                    return $this->addComplexType($type);
+                else
+                    return 'xsd:anyType';
+            }
+    }
+
+    /**
+     * Add a {@link http://www.w3.org/TR/wsdl#_types types} data type definition
+     *
+     * @param string $type Name of the class to be specified
+     * @return string XSD Type for the given PHP type
+     */
+    public function addComplexType($type)
+    {
+        if (in_array($type, $this->_includedTypes)) {
+            return "tns:$type";
+        }
+
+        if ($this->_schema === null) {
+            $this->_schema = $this->_dom->createElement('xsd:schema');
+            $this->_schema->setAttribute('targetNamespace', $this->_uri);
+            $types = $this->_dom->createElement('types');
+            $types->appendChild($this->_schema);
+            $this->_wsdl->appendChild($types);
+        }
+
+        $class = new ReflectionClass($type);
+
+        $complexType = $this->_dom->createElement('xsd:complexType');
+        $complexType->setAttribute('name', $type);
+
+        $all = $this->_dom->createElement('xsd:all');
+
+        foreach ($class->getProperties() as $property) {
+            if (preg_match_all('/@var\s+([^\s]+)/m', $property->getDocComment(), $matches)) {
+
+            	/**
+            	 * @todo check if 'xsd:element' must be used here (it may not be compatible with using 'complexType'
+            	 * node for describing other classes used as attribute types for current class
+            	 */
+                $element = $this->_dom->createElement('xsd:element');
+                $element->setAttribute('name', $property->getName());
+                $element->setAttribute('type', $this->getType(trim($matches[1][0])));
+                $all->appendChild($element);
+            }
+        }
+
+        $complexType->appendChild($all);
+        $this->_schema->appendChild($complexType);
+
+        $this->_includedTypes[] = $type;
+
+        return "tns:$type";
+    }
 }
