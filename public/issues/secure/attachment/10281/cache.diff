Index: library/Zend/Cache/Backend.php
===================================================================
--- library/Zend/Cache/Backend.php	(revision 3549)
+++ library/Zend/Cache/Backend.php	(working copy)
@@ -20,7 +20,7 @@
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
 
- 
+
 /**
  * @package    Zend_Cache
  * @subpackage Backend
@@ -28,44 +28,44 @@
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
 class Zend_Cache_Backend
-{   
-   
+{
+
     // ------------------
     // --- Properties ---
     // ------------------
-    
+
     /**
      * Frontend or Core directives
-     * 
-     * =====> (int) lifeTime :
+     *
+     * =====> (int) Lifetime :
      * - Cache lifetime (in seconds)
      * - If null, the cache is valid forever
-     * 
+     *
      * =====> (int) logging :
      * - if set to true, a logging is activated throw Zend_Log
-     * 
+     *
      * @var array directives
      */
     protected $_directives = array(
-        'lifeTime' => 3600,
+        'Lifetime' => 3600,
         'logging' => false
-    );  
-    
+    );
+
     /**
      * Available options
-     * 
+     *
      * @var array available options
      */
     protected $_options = array();
-    
-    
+
+
     // ----------------------
     // --- Public methods ---
     // ----------------------
-    
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
@@ -74,11 +74,11 @@
         while (list($name, $value) = each($options)) {
             $this->setOption($name, $value);
         }
-    }  
-     
+    }
+
     /**
      * Set the frontend directives
-     * 
+     *
      * @param array $directives assoc of directives
      */
     public function setDirectives($directives)
@@ -98,40 +98,40 @@
                 }
             }
         }
-    } 
-    
+    }
+
     /**
      * Set an option
-     * 
+     *
      * @param string $name
      * @param mixed $value
-     */ 
+     */
     public function setOption($name, $value)
     {
         if (!is_string($name) || !array_key_exists($name, $this->_options)) {
             Zend_Cache::throwException("Incorrect option name : $name");
         }
         $this->_options[$name] = $value;
-    }   
-    
+    }
+
     /**
      * Get the life time
-     * 
+     *
      * if $specificLifeTime is not false, the given specific life time is used
-     * else, the global lifeTime is used
-     * 
+     * else, the global Lifetime is used
+     *
      * @return int cache life time
      */
     public function getLifeTime($specificLifeTime)
     {
         if ($specificLifeTime === false) {
-            return $this->_directives['lifeTime'];
+            return $this->_directives['Lifetime'];
         }
         return $specificLifeTime;
     }
-    
+
     /**
-     * Return a system-wide tmp directory 
+     * Return a system-wide tmp directory
      *
      * @return string system-wide tmp directory
      */
@@ -158,5 +158,5 @@
             return '/tmp';
         }
     }
-    
+
 }
Index: library/Zend/Cache/Backend/Apc.php
===================================================================
--- library/Zend/Cache/Backend/Apc.php	(revision 3549)
+++ library/Zend/Cache/Backend/Apc.php	(working copy)
@@ -20,7 +20,7 @@
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
 
- 
+
 /**
  * Zend_Cache_Backend_Interface
  */
@@ -44,30 +44,30 @@
     // ----------------------
     // --- Public methods ---
     // ----------------------
-    
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
-    {      
+    {
         if (!extension_loaded('apc')) {
             Zend_Cache::throwException('The apc extension must be loaded for using this backend !');
         }
         parent::__construct($options);
-    }  
-           
+    }
+
     /**
      * Test if a cache is available for the given id and (if yes) return it (false else)
-     * 
+     *
      * WARNING $doNotTestCacheValidity=true is unsupported by the APC backend
-     * 
+     *
      * @param string $id cache id
      * @param boolean $doNotTestCacheValidity if set to true, the cache validity won't be tested
      * @return string cached datas (or false)
      */
-    public function load($id, $doNotTestCacheValidity = false) 
+    public function load($id, $doNotTestCacheValidity = false)
     {
         if ($doNotTestCacheValidity) {
             if ($this->_directives['logging']) {
@@ -80,10 +80,10 @@
         }
         return false;
     }
-    
+
     /**
      * Test if a cache is available or not (for the given id)
-     * 
+     *
      * @param string $id cache id
      * @return mixed false (a cache is not available) or "last modified" timestamp (int) of the available cache record
      */
@@ -95,58 +95,58 @@
         }
         return false;
     }
-    
+
     /**
      * Save some string datas into a cache record
      *
-     * Note : $data is always "string" (serialization is done by the 
+     * Note : $data is always "string" (serialization is done by the
      * core not by the backend)
      *
      * @param string $data datas to cache
      * @param string $id cache id
      * @param array $tags array of strings, the cache record will be tagged by each string entry
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)
+     * @param int $specificLifetime if != false, set a specific lifetime for this cache record (null => infinite lifetime)
      * @return boolean true if no problem
      */
-    public function save($data, $id, $tags = array(), $specificLifeTime = false)
+    public function save($data, $id, $tags = array(), $specificLifetime = false)
     {
-        $lifeTime = $this->getLifeTime($specificLifeTime);
-        $result = apc_store($id, array($data, time()), $lifeTime);
+        $lifetime = $this->getLifetime($specificLifetime);
+        $result = apc_store($id, array($data, time()), $lifetime);
         if (count($tags) > 0) {
             if ($this->_directives['logging']) {
                 Zend_Log::log("Zend_Cache_Backend_APC::save() : tags are unsupported by the APC backend", Zend_Log::LEVEL_WARNING);
             }
         }
-        return $result;       
+        return $result;
     }
-    
+
     /**
      * Remove a cache record
-     * 
+     *
      * @param string $id cache id
      * @return boolean true if no problem
      */
-    public function remove($id) 
+    public function remove($id)
     {
         return apc_delete($id);
     }
-    
+
     /**
      * Clean some cache records
      *
      * Available modes are :
      * 'all' (default)  => remove all cache entries ($tags is not used)
-     * 'old'            => remove too old cache entries ($tags is not used) 
-     * 'matchingTag'    => remove cache entries matching all given tags 
-     *                     ($tags can be an array of strings or a single string) 
+     * 'old'            => remove too old cache entries ($tags is not used)
+     * 'matchingTag'    => remove cache entries matching all given tags
+     *                     ($tags can be an array of strings or a single string)
      * 'notMatchingTag' => remove cache entries not matching one of the given tags
-     *                     ($tags can be an array of strings or a single string)    
-     * 
+     *                     ($tags can be an array of strings or a single string)
+     *
      * @param string $mode clean mode
      * @param tags array $tags array of tags
      * @return boolean true if no problem
      */
-    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array()) 
+    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array())
     {
         if ($mode==Zend_Cache::CLEANING_MODE_ALL) {
             return apc_clear_cache('user');
@@ -167,5 +167,5 @@
             }
         }
     }
-        
+
 }
Index: library/Zend/Cache/Backend/File.php
===================================================================
--- library/Zend/Cache/Backend/File.php	(revision 3549)
+++ library/Zend/Cache/Backend/File.php	(working copy)
@@ -20,7 +20,7 @@
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
 
- 
+
 /**
  * Zend_Cache_Backend_Interface
  */
@@ -38,51 +38,51 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
-class Zend_Cache_Backend_File extends Zend_Cache_Backend implements Zend_Cache_Backend_Interface 
+class Zend_Cache_Backend_File extends Zend_Cache_Backend implements Zend_Cache_Backend_Interface
 {
-    
+
     // ------------------
     // --- Properties ---
     // ------------------
-       
+
     /**
      * Available options
-     * 
+     *
      * =====> (string) cacheDir :
      * - Directory where to put the cache files
-     * 
+     *
      * =====> (boolean) fileLocking :
      * - Enable / disable fileLocking
      * - Can avoid cache corruption under bad circumstances but it doesn't work on multithread
      * webservers and on NFS filesystems for example
-     * 
+     *
      * =====> (boolean) readControl :
      * - Enable / disable read control
      * - If enabled, a control key is embeded in cache file and this key is compared with the one
      * calculated after the reading.
-     * 
+     *
      * =====> (string) readControlType :
      * - Type of read control (only if read control is enabled). Available values are :
      *   'md5' for a md5 hash control (best but slowest)
      *   'crc32' for a crc32 hash control (lightly less safe but faster, better choice)
      *   'strlen' for a length only test (fastest)
-     *   
+     *
      * =====> (int) hashedDirectoryLevel :
      * - Hashed directory level
-     * - Set the hashed directory structure level. 0 means "no hashed directory 
-     * structure", 1 means "one level of directory", 2 means "two levels"... 
-     * This option can speed up the cache only when you have many thousands of 
-     * cache file. Only specific benchs can help you to choose the perfect value 
+     * - Set the hashed directory structure level. 0 means "no hashed directory
+     * structure", 1 means "one level of directory", 2 means "two levels"...
+     * This option can speed up the cache only when you have many thousands of
+     * cache file. Only specific benchs can help you to choose the perfect value
      * for you. Maybe, 1 or 2 is a good start.
-     * 
+     *
      * =====> (int) hashedDirectoryUmask :
      * - Umask for hashed directory structure
-     * 
+     *
      * =====> (string) fileNamePrefix :
-     * - prefix for cache files 
+     * - prefix for cache files
      * - be really carefull with this option because a too generic value in a system cache dir
      *   (like /tmp) can cause disasters when cleaning the cache
-     * 
+     *
      * @var array available options
      */
     protected $_options = array(
@@ -94,18 +94,18 @@
         'hashedDirectoryUmask' => 0700,
         'fileNamePrefix' => 'zend_cache'
     );
-    
+
     // ----------------------
     // --- Public methods ---
     // ----------------------
-    
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
-    {   
+    {
         parent::__construct($options);
         if (isset($options['cacheDir'])) { // particular case for this option
             $this->setCacheDir($options['cacheDir']);
@@ -117,28 +117,28 @@
                 Zend_Cache::throwException('Invalid fileNamePrefix : must use only [a-zA-A0-9_]');
             }
         }
-    }  
-    
+    }
+
     /**
      * Set the cacheDir (particular case of setOption() method)
-     * 
+     *
      * @param mixed $value
      */
     public function setCacheDir($value)
     {
-        // add a trailing DIRECTORY_SEPARATOR if necessary 
+        // add a trailing DIRECTORY_SEPARATOR if necessary
         $value = rtrim($value, '\\/') . DIRECTORY_SEPARATOR;
         $this->setOption('cacheDir', $value);
     }
-       
+
     /**
      * Test if a cache is available for the given id and (if yes) return it (false else)
-     * 
+     *
      * @param string $id cache id
      * @param boolean $doNotTestCacheValidity if set to true, the cache validity won't be tested
      * @return string cached datas (or false)
      */
-    public function load($id, $doNotTestCacheValidity = false) 
+    public function load($id, $doNotTestCacheValidity = false)
     {
         if (!($this->_test($id, $doNotTestCacheValidity))) {
             // The cache is not hit !
@@ -158,7 +158,7 @@
         if ($this->_options['readControl']) {
             $hashControl = @fread($fp, 32);
             $length = $length - 32;
-        } 
+        }
         if ($length) {
             $data = @fread($fp, $length);
         } else {
@@ -175,15 +175,15 @@
                     Zend_Log::log('Zend_Cache_Backend_File::load() / readControl : stored hash and computed hash do not match', Zend_Log::LEVEL_WARNING);
                 }
                 $this->_remove($file);
-                return false;    
+                return false;
             }
         }
         return $data;
     }
-    
+
     /**
      * Test if a cache is available or not (for the given id)
-     * 
+     *
      * @param string $id cache id
      * @return mixed false (a cache is not available) or "last modified" timestamp (int) of the available cache record
      */
@@ -191,20 +191,20 @@
     {
         return $this->_test($id, false);
     }
-    
+
     /**
      * Save some string datas into a cache record
      *
-     * Note : $data is always "string" (serialization is done by the 
+     * Note : $data is always "string" (serialization is done by the
      * core not by the backend)
      *
      * @param string $data datas to cache
      * @param string $id cache id
      * @param array $tags array of strings, the cache record will be tagged by each string entry
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)
+     * @param int $specificLifetime if != false, set a specific lifetime for this cache record (null => infinite Lifetime)
      * @return boolean true if no problem
      */
-    public function save($data, $id, $tags = array(), $specificLifeTime = false)
+    public function save($data, $id, $tags = array(), $specificLifetime = false)
     {
         if ((!is_dir($this->_options['cacheDir'])) or (!is_writable($this->_options['cacheDir']))) {
             if ($this->_directives['logging']) {
@@ -212,8 +212,8 @@
             }
         }
         $this->remove($id); // to avoid multiple files with the same cache id
-        $lifeTime = $this->getLifeTime($specificLifeTime);
-        $expire = $this->_expireTime($lifeTime);
+        $Lifetime = $this->getLifetime($specificLifetime);
+        $expire = $this->_expireTime($Lifetime);
         $file = $this->_file($id, $expire);
         $firstTry = true;
         $result = false;
@@ -233,17 +233,17 @@
                 set_magic_quotes_runtime($mqr);
                 $result = true;
                 break;
-            }         
+            }
             // we can't open the file but it's maybe only the directory structure
             // which has to be built
             if ($this->_options['hashedDirectoryLevel']==0) break;
             if ((!$firstTry) || ($this->_options['hashedDirectoryLevel'] == 0)) {
                 // it's not a problem of directory structure
                 break;
-            } 
+            }
             $firstTry = false;
             // In this case, maybe we just need to create the corresponding directory
-            @mkdir($this->_path($id), $this->_options['hashedDirectoryUmask'], true);    
+            @mkdir($this->_path($id), $this->_options['hashedDirectoryUmask'], true);
             @chmod($this->_options['hashedDirectoryUmask']); // see #ZF-320 (this line is required in some configurations)
         }
         if ($result) {
@@ -253,14 +253,14 @@
         }
         return $result;
     }
-    
+
     /**
      * Remove a cache record
-     * 
+     *
      * @param string $id cache id
      * @return boolean true if no problem
      */
-    public function remove($id) 
+    public function remove($id)
     {
         $result1 = true;
         $files = @glob($this->_file($id, '*'));
@@ -273,34 +273,34 @@
         $result2 = $this->_unregisterTag($id);
         return ($result1 && $result2);
     }
-    
+
     /**
      * Clean some cache records
      *
      * Available modes are :
      * 'all' (default)  => remove all cache entries ($tags is not used)
-     * 'old'            => remove too old cache entries ($tags is not used) 
-     * 'matchingTag'    => remove cache entries matching all given tags 
-     *                     ($tags can be an array of strings or a single string) 
+     * 'old'            => remove too old cache entries ($tags is not used)
+     * 'matchingTag'    => remove cache entries matching all given tags
+     *                     ($tags can be an array of strings or a single string)
      * 'notMatchingTag' => remove cache entries not matching one of the given tags
-     *                     ($tags can be an array of strings or a single string)    
-     * 
+     *                     ($tags can be an array of strings or a single string)
+     *
      * @param string $mode clean mode
      * @param tags array $tags array of tags
      * @return boolean true if no problem
      */
-    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array()) 
+    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array())
     {
         // We use this private method to hide the recursive stuff
         clearstatcache();
         return $this->_clean($this->_options['cacheDir'], $mode, $tags);
     }
-    
+
     /**
      * PUBLIC METHOD FOR UNIT TESTING ONLY !
-     * 
+     *
      * Force a cache record to expire
-     * 
+     *
      * @param string $id cache id
      */
     public function ___expire($id)
@@ -311,20 +311,20 @@
             @rename($file, $file2);
         }
     }
-    
+
     // -----------------------
     // --- Private methods ---
     // -----------------------
-    
+
     /**
      * Remove a file
-     * 
-     * If we can't remove the file (because of locks or any problem), we will touch 
+     *
+     * If we can't remove the file (because of locks or any problem), we will touch
      * the file to invalidate it
-     * 
+     *
      * @param string $file complete file path
      * @return boolean true if ok
-     */  
+     */
     private function _remove($file)
     {
         if (!@unlink($file)) {
@@ -333,13 +333,13 @@
                 Zend_Log::log("Zend_Cache_Backend_File::_remove() : we can't remove $file => we are going to try to invalidate it", Zend_Log::LEVEL_WARNING);
             }
             return false;
-        } 
+        }
         return true;
     }
-    
+
     /**
      * Test if the given cache id is available (and still valid as a cache record)
-     * 
+     *
      * @param string $id cache id
      * @param boolean $doNotTestCacheValidity if set to true, the cache validity won't be tested
      * @return boolean mixed false (a cache is not available) or "last modified" timestamp (int) of the available cache record
@@ -361,24 +361,24 @@
         }
         return false;
     }
-    
+
     /**
      * Clean some cache records (private method used for recursive stuff)
      *
      * Available modes are :
      * Zend_Cache::CLEANING_MODE_ALL (default)    => remove all cache entries ($tags is not used)
-     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used) 
-     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags 
-     *                                               ($tags can be an array of strings or a single string) 
+     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used)
+     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags
+     *                                               ($tags can be an array of strings or a single string)
      * Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG => remove cache entries not {matching one of the given tags}
-     *                                               ($tags can be an array of strings or a single string)    
-     * 
+     *                                               ($tags can be an array of strings or a single string)
+     *
      * @param string $dir directory to clean
      * @param string $mode clean mode
      * @param tags array $tags array of tags
      * @return boolean true if no problem
      */
-    private function _clean($dir, $mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array()) 
+    private function _clean($dir, $mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array())
     {
         if (!is_dir($dir)) {
             return false;
@@ -400,7 +400,7 @@
                 }
                 if ($mode==Zend_Cache::CLEANING_MODE_MATCHING_TAG) {
                     $matching = true;
-                    $id = $this->_fileNameToId(basename($file)); 
+                    $id = $this->_fileNameToId(basename($file));
                     if (!($this->_isATag($id))) {
                         foreach ($tags as $tag) {
                             if (!($this->_testTag($id, $tag))) {
@@ -426,77 +426,77 @@
                         if (!$matching) {
                             $result = ($result) && ($this->remove($id));
                         }
-                    }                               
+                    }
                 }
             }
             if ((is_dir($file)) and ($this->_options['hashedDirectoryLevel']>0)) {
                 // Recursive call
                 $result = ($result) && ($this->_clean($file . DIRECTORY_SEPARATOR, $mode, $tags));
                 if ($mode=='all') {
-                    // if mode=='all', we try to drop the structure too                    
+                    // if mode=='all', we try to drop the structure too
                     @rmdir($file);
                 }
             }
         }
-        return $result;  
+        return $result;
     }
-    
+
     /**
      * Register a cache id with the given tag
-     * 
+     *
      * @param string $id cache id
      * @param string $tag tag
      * @return boolean true if no problem
      */
-    private function _registerTag($id, $tag) 
+    private function _registerTag($id, $tag)
     {
         return $this->save('1', $this->_tagCacheId($id, $tag));
     }
-    
+
     /**
      * Unregister tags of a cache id
-     * 
+     *
      * @param string $id cache id
      * @return boolean true if no problem
      */
-    private function _unregisterTag($id) 
+    private function _unregisterTag($id)
     {
         $filesToRemove = @glob($this->_file($this->_tagCacheId($id, '*'), '*'));
         $result = true;
         foreach ($filesToRemove as $file) {
             $result = $result && ($this->_remove($file));
-        }    
-        return $result;    
+        }
+        return $result;
     }
-    
+
     /**
      * Test if a cache id was saved with the given tag
-     * 
+     *
      * @param string $id cache id
      * @param string $tag tag name
      * @return true if the cache id was saved with the given tag
      */
-    private function _testTag($id, $tag) 
+    private function _testTag($id, $tag)
     {
         if ($this->test($this->_tagCacheId($id, $tag))) {
            return true;
         }
         return false;
     }
-    
+
     /**
      * Compute & return the expire time
-     * 
+     *
      * @return int expire time (unix timestamp)
      */
-    private function _expireTime($lifeTime) 
+    private function _expireTime($Lifetime)
     {
-        if (is_null($this->_directives['lifeTime'])) {
+        if (is_null($this->_directives['Lifetime'])) {
             return 9999999999;
         }
-        return time() + $lifeTime;
+        return time() + $Lifetime;
     }
-    
+
     /**
      * Make a control key with the string containing datas
      *
@@ -517,10 +517,10 @@
             Zend_Cache::throwException("Incorrect hash function : $controlType");
         }
     }
-      
+
     /**
      * Return a special/reserved cache id for storing the given tag on the given id
-     * 
+     *
      * @param string $id cache id
      * @param string $tag tag name
      * @return string cache id for the tag
@@ -528,10 +528,10 @@
     private function _tagCacheId($id, $tag) {
         return 'internal-' . $id . '-' . $tag;
     }
-    
+
     /**
      * Return true is the given id is a tag
-     * 
+     *
      * @param string $id
      * @return boolean
      */
@@ -542,10 +542,10 @@
         }
         return false;
     }
-    
+
     /**
      * Transform a cache id into a file name and return it
-     * 
+     *
      * @param string $id cache id
      * @param int expire timestamp
      * @return string file name
@@ -556,21 +556,21 @@
         $result = $prefix . '---' . $id . '---' . $expire;
         return $result;
     }
-    
+
     /**
      * Get the father cache id from the tag cache id
-     * 
+     *
      * @param string $id tag cache id
      * @return string father cache id
      */
     private function _tagCacheIdToFatherCacheId($id)
     {
-        return preg_replace('~internal-(\w*)-.*$~', '$1', $id);    
+        return preg_replace('~internal-(\w*)-.*$~', '$1', $id);
     }
-    
+
     /**
      * Return the expire field from the file name
-     * 
+     *
      * @param string $fileName
      * @return string expire field
      */
@@ -579,22 +579,22 @@
         $prefix = $this->_options['fileNamePrefix'];
         return preg_replace('~^' . $prefix . '---.*---(\d*)$~', '$1', $fileName);
     }
-    
+
     /**
      * Transform a file name into cache id and return it
-     * 
+     *
      * @param string $fileName file name
      * @return string cache id
      */
-    private function _fileNameToId($fileName) 
-    {       
+    private function _fileNameToId($fileName)
+    {
         $prefix = $this->_options['fileNamePrefix'];
         return preg_replace('~^' . $prefix . '---(.*)---.*$~', '$1', $fileName);
     }
-    
+
     /**
      * Return the complete directory path of a filename (including hashedDirectoryStructure)
-     * 
+     *
      * @param string $id cache id
      * @return string complete directory path
      */
@@ -612,11 +612,11 @@
             }
             for ($i=0 ; $i<$this->_options['hashedDirectoryLevel'] ; $i++) {
                 $root = $root . $prefix . '--' . substr($hash, 0, $i + 1) . DIRECTORY_SEPARATOR;
-            }             
+            }
         }
         return $root;
     }
-    
+
     /**
      * Make and return a file name (with path)
      *
@@ -626,7 +626,7 @@
      * @param string $id cache id
      * @param int expire timestamp
      * @return string file name (with path)
-     */  
+     */
     private function _file($id, $expire = null)
     {
         $path = $this->_path($id);
@@ -636,10 +636,10 @@
             if ($nbr == 1) {
                 return $glob[0];
             }
-            return null;       
+            return null;
         }
         $fileName = $this->_idToFileName($id, $expire);
         return $path . $fileName;
     }
-    
+
 }
Index: library/Zend/Cache/Backend/Interface.php
===================================================================
--- library/Zend/Cache/Backend/Interface.php	(revision 3549)
+++ library/Zend/Cache/Backend/Interface.php	(working copy)
@@ -19,8 +19,8 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
- 
- 
+
+
 /**
  * @package    Zend_Cache
  * @subpackage Backend
@@ -29,70 +29,70 @@
  */
 interface Zend_Cache_Backend_Interface
 {
-   
+
     /**
      * Set the frontend directives
-     * 
+     *
      * @param array $directives assoc of directives
      */
     public function setDirectives($directives);
-       
+
     /**
      * Test if a cache is available for the given id and (if yes) return it (false else)
-     * 
+     *
      * Note : return value is always "string" (unserialization is done by the core not by the backend)
-     * 
+     *
      * @param string $id cache id
      * @param boolean $doNotTestCacheValidity if set to true, the cache validity won't be tested
      * @return string cached datas (or false)
      */
     public function load($id, $doNotTestCacheValidity = false);
-    
+
     /**
      * Test if a cache is available or not (for the given id)
-     * 
+     *
      * @param string $id cache id
      * @return mixed false (a cache is not available) or "last modified" timestamp (int) of the available cache record
      */
     public function test($id);
-    
+
     /**
      * Save some string datas into a cache record
      *
-     * Note : $data is always "string" (serialization is done by the 
+     * Note : $data is always "string" (serialization is done by the
      * core not by the backend)
      *
      * @param string $data datas to cache
      * @param string $id cache id
      * @param array $tags array of strings, the cache record will be tagged by each string entry
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)    
+     * @param int $specificLifetime if != false, set a specific lifetime for this cache record (null => infinite lifetime)
      * @return boolean true if no problem
      */
-    public function save($data, $id, $tags = array(), $specificLifeTime = false);
-    
+    public function save($data, $id, $tags = array(), $specificLifetime = false);
+
     /**
      * Remove a cache record
-     * 
+     *
      * @param string $id cache id
      * @return boolean true if no problem
      */
     public function remove($id);
-    
+
     /**
      * Clean some cache records
      *
      * Available modes are :
      * Zend_Cache::CLEANING_MODE_ALL (default)    => remove all cache entries ($tags is not used)
-     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used) 
-     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags 
-     *                                               ($tags can be an array of strings or a single string) 
+     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used)
+     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags
+     *                                               ($tags can be an array of strings or a single string)
      * Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG => remove cache entries not {matching one of the given tags}
-     *                                               ($tags can be an array of strings or a single string)      
-     * 
+     *                                               ($tags can be an array of strings or a single string)
+     *
      * @param string $mode clean mode
      * @param tags array $tags array of tags
      * @return boolean true if no problem
      */
-    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array());  
-    
+    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array());
+
 }
Index: library/Zend/Cache/Backend/Memcached.php
===================================================================
--- library/Zend/Cache/Backend/Memcached.php	(revision 3549)
+++ library/Zend/Cache/Backend/Memcached.php	(working copy)
@@ -20,7 +20,7 @@
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
 
- 
+
 /**
  * Zend_Cache_Backend_Interface
  */
@@ -38,32 +38,32 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
-class Zend_Cache_Backend_Memcached extends Zend_Cache_Backend implements Zend_Cache_Backend_Interface 
+class Zend_Cache_Backend_Memcached extends Zend_Cache_Backend implements Zend_Cache_Backend_Interface
 {
-    
+
     // -----------------
     // --- Constants ---
     // -----------------
     const DEFAULT_HOST       = '127.0.0.1';
     const DEFAULT_PORT       = 11211;
     const DEFAULT_PERSISTENT = true;
-    
+
     // ------------------
     // --- Properties ---
     // ------------------
-       
+
     /**
      * Available options
-     * 
+     *
      * =====> (array) servers :
      * an array of memcached server ; each memcached server is described by an associative array :
      * 'host' => (string) : the name of the memcached server
      * 'port' => (int) : the port of the memcached server
      * 'persistent' => (bool) : use or not persistent connections to this memcached server
-     * 
+     *
      * =====> (boolean) compression :
      * true if you want to use on-the-fly compression
-     * 
+     *
      * @var array available options
      */
     protected $_options = array(
@@ -74,26 +74,26 @@
         )),
         'compression' => false
     );
-     
+
     /**
      * Memcache object
-     * 
+     *
      * @var mixed memcache object
      */
     private $_memcache = null;
-    
-    
+
+
     // ----------------------
     // --- Public methods ---
     // ----------------------
-    
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
-    {      
+    {
         if (!extension_loaded('memcache')) {
             Zend_Cache::throwException('The memcache extension must be loaded for using this backend !');
         }
@@ -116,16 +116,16 @@
             }
             $this->_memcache->addServer($server['host'], $server['port'], $server['persistent']);
         }
-    }  
-       
+    }
+
     /**
      * Test if a cache is available for the given id and (if yes) return it (false else)
-     * 
+     *
      * @param string $id cache id
      * @param boolean $doNotTestCacheValidity if set to true, the cache validity won't be tested
      * @return string cached datas (or false)
      */
-    public function load($id, $doNotTestCacheValidity = false) 
+    public function load($id, $doNotTestCacheValidity = false)
     {
         // WARNING : $doNotTestCacheValidity is not supported !!!
         if ($doNotTestCacheValidity) {
@@ -139,10 +139,10 @@
         }
         return false;
     }
-    
+
     /**
      * Test if a cache is available or not (for the given id)
-     * 
+     *
      * @param string $id cache id
      * @return mixed false (a cache is not available) or "last modified" timestamp (int) of the available cache record
      */
@@ -154,63 +154,63 @@
         }
         return false;
     }
-    
+
     /**
      * Save some string datas into a cache record
      *
-     * Note : $data is always "string" (serialization is done by the 
+     * Note : $data is always "string" (serialization is done by the
      * core not by the backend)
      *
      * @param string $data datas to cache
      * @param string $id cache id
      * @param array $tags array of strings, the cache record will be tagged by each string entry
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)
+     * @param int $specificLifetime if != false, set a specific lifetime for this cache record (null => infinite lifetime)
      * @return boolean true if no problem
      */
-    public function save($data, $id, $tags = array(), $specificLifeTime = false)
+    public function save($data, $id, $tags = array(), $specificLifetime = false)
     {
-        $lifeTime = $this->getLifeTime($specificLifeTime);
+        $lifetime = $this->getLifetime($specificLifetime);
         if ($this->_options['compression']) {
             $flag = MEMCACHE_COMPRESSED;
         } else {
             $flag = 0;
         }
-        $result = $this->_memcache->set($id, array($data, time()), $flag, $lifeTime);
+        $result = $this->_memcache->set($id, array($data, time()), $flag, $lifetime);
         if (count($tags) > 0) {
             if ($this->_directives['logging']) {
                 Zend_Log::log("Zend_Cache_Backend_Memcached::save() : tags are unsupported by the Memcached backend", Zend_Log::LEVEL_WARNING);
             }
         }
-        return $result;       
+        return $result;
     }
-    
+
     /**
      * Remove a cache record
-     * 
+     *
      * @param string $id cache id
      * @return boolean true if no problem
      */
-    public function remove($id) 
+    public function remove($id)
     {
         return $this->_memcache->delete($id);
     }
-    
+
     /**
      * Clean some cache records
      *
      * Available modes are :
      * 'all' (default)  => remove all cache entries ($tags is not used)
-     * 'old'            => remove too old cache entries ($tags is not used) 
-     * 'matchingTag'    => remove cache entries matching all given tags 
-     *                     ($tags can be an array of strings or a single string) 
+     * 'old'            => remove too old cache entries ($tags is not used)
+     * 'matchingTag'    => remove cache entries matching all given tags
+     *                     ($tags can be an array of strings or a single string)
      * 'notMatchingTag' => remove cache entries not matching one of the given tags
-     *                     ($tags can be an array of strings or a single string)    
-     * 
+     *                     ($tags can be an array of strings or a single string)
+     *
      * @param string $mode clean mode
      * @param tags array $tags array of tags
      * @return boolean true if no problem
      */
-    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array()) 
+    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array())
     {
         if ($mode==Zend_Cache::CLEANING_MODE_ALL) {
             return $this->_memcache->flush();
@@ -231,5 +231,5 @@
             }
         }
     }
-        
+
 }
Index: library/Zend/Cache/Backend/Sqlite.php
===================================================================
--- library/Zend/Cache/Backend/Sqlite.php	(revision 3549)
+++ library/Zend/Cache/Backend/Sqlite.php	(working copy)
@@ -19,8 +19,8 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
- 
- 
+
+
 /**
  * Zend_Cache_Backend_Interface
  */
@@ -37,53 +37,53 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
-class Zend_Cache_Backend_Sqlite extends Zend_Cache_Backend implements Zend_Cache_Backend_Interface 
+class Zend_Cache_Backend_Sqlite extends Zend_Cache_Backend implements Zend_Cache_Backend_Interface
 {
-    
+
     // ------------------
     // --- Properties ---
     // ------------------
-       
+
     /**
      * Available options
-     * 
+     *
      * =====> (string) cacheDBCompletePath :
      * - the complete path (filename included) of the SQLITE database
-     * 
+     *
      * ====> (int) automaticVacuumFactor :
      * - Disable / Tune the automatic vacuum process
      * - The automatic vacuum process defragment the database file (and make it smaller)
      *   when a clean() or delete() is called
-     *     0               => no automatic vacuum 
+     *     0               => no automatic vacuum
      *     1               => systematic vacuum (when delete() or clean() methods are called)
      *     x (integer) > 1 => automatic vacuum randomly 1 times on x clean() or delete()
-     * 
+     *
      * @var array available options
      */
     protected $_options = array(
         'cacheDBCompletePath' => null,
         'automaticVacuumFactor' => 10
-    ); 
-  
+    );
+
     /**
-     * DB ressource 
-     * 
+     * DB ressource
+     *
      * @var mixed $_db
      */
     private $_db = null;
-    
-    
+
+
     // ----------------------
     // --- Public methods ---
     // ----------------------
-    
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
-    {      
+    {
         if (!isset($options['cacheDBCompletePath'])) Zend_Cache::throwException('cacheDBCompletePath option has to set');
         $this->_db = @sqlite_open($options['cacheDBCompletePath']);
         if (!($this->_db)) {
@@ -91,7 +91,7 @@
         }
         parent::__construct($options);
     }
-    
+
     /**
      * Destructor
      */
@@ -99,15 +99,15 @@
     {
         @sqlite_close($this->_db);
     }
-            
+
     /**
      * Test if a cache is available for the given id and (if yes) return it (false else)
-     * 
+     *
      * @param string $id cache id
      * @param boolean $doNotTestCacheValidity if set to true, the cache validity won't be tested
      * @return string cached datas (or false)
      */
-    public function load($id, $doNotTestCacheValidity = false) 
+    public function load($id, $doNotTestCacheValidity = false)
     {
         $sql = "SELECT content FROM cache WHERE id='$id'";
         if (!$doNotTestCacheValidity) {
@@ -120,10 +120,10 @@
         }
         return false;
     }
-    
+
     /**
      * Test if a cache is available or not (for the given id)
-     * 
+     *
      * @param string $id cache id
      * @return mixed false (a cache is not available) or "last modified" timestamp (int) of the available cache record
      */
@@ -137,38 +137,38 @@
         }
         return false;
     }
-    
+
     /**
      * Save some string datas into a cache record
      *
-     * Note : $data is always "string" (serialization is done by the 
+     * Note : $data is always "string" (serialization is done by the
      * core not by the backend)
      *
      * @param string $data datas to cache
      * @param string $id cache id
      * @param array $tags array of strings, the cache record will be tagged by each string entry
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)
+     * @param int $specificLifetime if != false, set a specific lifetime for this cache record (null => infinite lifetime)
      * @return boolean true if no problem
      */
-    public function save($data, $id, $tags = array(), $specificLifeTime = false)
+    public function save($data, $id, $tags = array(), $specificLifetime = false)
     {
         if (!$this->_checkStructureVersion()) {
             $this->_buildStructure();
             if (!$this->_checkStructureVersion()) {
                 Zend_Cache::throwException("Impossible to build cache structure in " . $this->_options['cacheDBCompletePath']);
             }
-        }    
-        $lifeTime = $this->getLifeTime($specificLifeTime);
+        }
+        $lifetime = $this->getLifetime($specificLifetime);
         $data = @sqlite_escape_string($data);
         $mktime = time();
-        if (is_null($lifeTime)) {
+        if (is_null($lifetime)) {
             $expire = 0;
         } else {
-            $expire = $mktime + $lifeTime;
+            $expire = $mktime + $lifetime;
         }
         @sqlite_query($this->_db, "DELETE FROM cache WHERE id='$id'");
         $sql = "INSERT INTO cache (id, content, lastModified, expire) VALUES ('$id', '$data', $mktime, $expire)";
-        $res = @sqlite_query($this->_db, $sql);       
+        $res = @sqlite_query($this->_db, $sql);
         if (!$res) {
             if ($this->_directives['logging']) {
                 Zend_Log::log("Zend_Cache_Backend_Sqlite::save() : impossible to store the cache id=$id", Zend_Log::LEVEL_WARNING);
@@ -181,50 +181,50 @@
         }
         return $res;
     }
-    
+
     /**
      * Remove a cache record
-     * 
+     *
      * @param string $id cache id
      * @return boolean true if no problem
      */
-    public function remove($id) 
+    public function remove($id)
     {
         $res = @sqlite_query($this->_db, "SELECT COUNT(*) AS nbr FROM cache WHERE id='$id'");
         $result1 = @sqlite_fetch_single($res);
         $result2 = @sqlite_query($this->_db, "DELETE FROM cache WHERE id='$id'");
-        $result3 = @sqlite_query($this->_db, "DELETE FROM tag WHERE id='$id'"); 
+        $result3 = @sqlite_query($this->_db, "DELETE FROM tag WHERE id='$id'");
         $this->_automaticVacuum();
-        return ($result1 && $result2 && $result3);       
+        return ($result1 && $result2 && $result3);
     }
-    
+
     /**
      * Clean some cache records
      *
      * Available modes are :
      * Zend_Cache::CLEANING_MODE_ALL (default)    => remove all cache entries ($tags is not used)
-     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used) 
-     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags 
-     *                                               ($tags can be an array of strings or a single string) 
+     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used)
+     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags
+     *                                               ($tags can be an array of strings or a single string)
      * Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG => remove cache entries not {matching one of the given tags}
-     *                                               ($tags can be an array of strings or a single string)      
-     * 
+     *                                               ($tags can be an array of strings or a single string)
+     *
      * @param string $mode clean mode
      * @param tags array $tags array of tags
      * @return boolean true if no problem
      */
-    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array()) 
+    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array())
     {
         $return = $this->_clean($mode, $tags);
         $this->_automaticVacuum();
         return $return;
     }
-    
+
     /**
      * PUBLIC METHOD FOR UNIT TESTING ONLY !
-     * 
+     *
      * Force a cache record to expire
-     * 
+     *
      * @param string $id cache id
      */
     public function ___expire($id)
@@ -232,10 +232,10 @@
         $time = time() - 1;
         @sqlite_query($this->_db, "UPDATE cache SET lastModified=$time, expire=$time WHERE id='$id'");
     }
-    
+
     /**
      * PUBLIC METHOD FOR UNIT TESTING ONLY !
-     * 
+     *
      * Unlink the database file
      */
     public function ___dropDatabaseFile()
@@ -243,15 +243,15 @@
         @sqlite_close($this->_db);
         @unlink($this->_options['cacheDBCompletePath']);
     }
-    
+
     // -----------------------
     // --- Private methods ---
     // -----------------------
-    
+
     /**
      * Deal with the automatic vacuum process
      */
-    private function _automaticVacuum() 
+    private function _automaticVacuum()
     {
         if ($this->_options['automaticVacuumFactor'] > 0) {
             $rand = rand(1, $this->_options['automaticVacuumFactor']);
@@ -260,10 +260,10 @@
             }
         }
     }
-    
+
     /**
      * Register a cache id with the given tag
-     * 
+     *
      * @param string $id cache id
      * @param string $tag tag
      * @return boolean true if no problem
@@ -271,7 +271,7 @@
     private function _registerTag($id, $tag) {
         $res = @sqlite_query($this->_db, "DELETE FROM TAG WHERE tag='$tag' AND id='$id'");
         $res = @sqlite_query($this->_db, "INSERT INTO tag (name, id) VALUES ('$tag', '$id')");
-        if (!$res) {        
+        if (!$res) {
             if ($this->_directives['logging']) {
                 Zend_Log::log("Zend_Cache_Backend_Sqlite::_registerTag() : impossible to register tag=$tag on id=$id", Zend_Log::LEVEL_WARNING);
             }
@@ -279,7 +279,7 @@
         }
         return true;
     }
-    
+
     /**
      * Build the database structure
      */
@@ -293,20 +293,20 @@
         @sqlite_query($this->_db, 'DROP TABLE tag');
         @sqlite_query($this->_db, 'CREATE TABLE version (num INTEGER PRIMARY KEY)');
         @sqlite_query($this->_db, 'CREATE TABLE cache (id TEXT PRIMARY KEY, content BLOB, lastModified INTEGER, expire INTEGER)');
-        @sqlite_query($this->_db, 'CREATE TABLE tag (name TEXT, id TEXT)');  
+        @sqlite_query($this->_db, 'CREATE TABLE tag (name TEXT, id TEXT)');
         @sqlite_query($this->_db, 'CREATE INDEX tag_id_index ON tag(id)');
         @sqlite_query($this->_db, 'CREATE INDEX tag_name_index ON tag(name)');
         @sqlite_query($this->_db, 'CREATE INDEX cache_id_expire_index ON cache(id, expire)');
-        @sqlite_query($this->_db, 'INSERT INTO version (num) VALUES (1)');        
+        @sqlite_query($this->_db, 'INSERT INTO version (num) VALUES (1)');
     }
-    
+
     /**
      * Check if the database structure is ok (with the good version)
-     * 
+     *
      * @return boolean true if ok
      */
     private function _checkStructureVersion()
-    {       
+    {
         $result = @sqlite_query($this->_db, "SELECT num FROM version");
         if (!$result) return false;
         $row = @sqlite_fetch_array($result);
@@ -322,23 +322,23 @@
         }
         return true;
     }
-    
+
     /**
      * Clean some cache records
      *
      * Available modes are :
      * Zend_Cache::CLEANING_MODE_ALL (default)    => remove all cache entries ($tags is not used)
-     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used) 
-     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags 
-     *                                               ($tags can be an array of strings or a single string) 
+     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used)
+     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags
+     *                                               ($tags can be an array of strings or a single string)
      * Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG => remove cache entries not {matching one of the given tags}
-     *                                               ($tags can be an array of strings or a single string)      
-     * 
+     *                                               ($tags can be an array of strings or a single string)
+     *
      * @param string $mode clean mode
      * @param tags array $tags array of tags
      * @return boolean true if no problem
      */
-    private function _clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array()) 
+    private function _clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array())
     {
         if ($mode==Zend_Cache::CLEANING_MODE_ALL) {
             $res1 = @sqlite_query($this->_db, 'DELETE FROM cache');
@@ -359,7 +359,7 @@
                 if (!$res) {
                     return false;
                 }
-                $rows = @sqlite_fetch_all($res, SQLITE_ASSOC);  
+                $rows = @sqlite_fetch_all($res, SQLITE_ASSOC);
                 $ids2 = array();
                 foreach ($rows as $row) {
                     $ids2[] = $row['id'];
@@ -379,7 +379,7 @@
         }
         if ($mode==Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG) {
             $res = @sqlite_query($this->_db, "SELECT id FROM cache");
-            $rows = @sqlite_fetch_all($res, SQLITE_ASSOC);    
+            $rows = @sqlite_fetch_all($res, SQLITE_ASSOC);
             $result = true;
             foreach ($rows as $row) {
                 $id = $row['id'];
@@ -397,10 +397,10 @@
                 if (!$matching) {
                     $result = $result && $this->remove($id);
                 }
-            }     
-            return $result;         
-        }     
+            }
+            return $result;
+        }
         return false;
     }
-    
+
 }
Index: library/Zend/Cache/Backend/Test.php
===================================================================
--- library/Zend/Cache/Backend/Test.php	(revision 3549)
+++ library/Zend/Cache/Backend/Test.php	(working copy)
@@ -20,7 +20,7 @@
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
 
- 
+
 /**
  * Zend_Cache_Backend_Interface
  */
@@ -33,78 +33,78 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
-class Zend_Cache_Backend_Test implements Zend_Cache_Backend_Interface 
+class Zend_Cache_Backend_Test implements Zend_Cache_Backend_Interface
 {
-    
+
     // ------------------
     // --- Properties ---
     // ------------------
-       
+
     /**
      * Available options
-     * 
+     *
      * @var array available options
      */
     private $_options = array();
-  
+
     /**
      * Frontend or Core directives
-     * 
+     *
      * @var array directives
      */
     private $_directives = array();
-    
+
     /**
      * Array to log actions
-     * 
+     *
      * @var array $_log
      */
     private $_log = array();
-    
+
     /**
      * Current index for log array
-     * 
+     *
      * @var int $_index
      */
     private $_index = 0;
-    
-    
+
+
     // ----------------------
     // --- Public methods ---
     // ----------------------
-    
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
-    {      
+    {
         $this->_addLog('construct', array($options));
     }
-    
+
     /**
      * Set the frontend directives
-     * 
+     *
      * @param array $directives assoc of directives
      */
     public function setDirectives($directives)
     {
         $this->_addLog('setDirectives', array($directives));
-    } 
-    
+    }
+
     /**
      * Test if a cache is available for the given id and (if yes) return it (false else)
-     * 
+     *
      * For this test backend only, if $id == 'false', then the method will return false
      * if $id == 'serialized', the method will return a serialized array
      * ('foo' else)
-     * 
+     *
      * @param string $id cache id
      * @param boolean $doNotTestCacheValidity if set to true, the cache validity won't be tested
      * @return string cached datas (or false)
      */
-    public function load($id, $doNotTestCacheValidity = false) 
+    public function load($id, $doNotTestCacheValidity = false)
     {
         $this->_addLog('get', array($id, $doNotTestCacheValidity));
         if ($id=='false') {
@@ -118,13 +118,13 @@
         }
         return 'foo';
     }
-    
+
     /**
      * Test if a cache is available or not (for the given id)
-     * 
+     *
      * For this test backend only, if $id == 'false', then the method will return false
      * (123456 else)
-     * 
+     *
      * @param string $id cache id
      * @return mixed false (a cache is not available) or "last modified" timestamp (int) of the available cache record
      */
@@ -139,7 +139,7 @@
         }
         return 123456;
     }
-    
+
     /**
      * Save some string datas into a cache record
      *
@@ -149,10 +149,10 @@
      * @param string $data datas to cache
      * @param string $id cache id
      * @param array $tags array of strings, the cache record will be tagged by each string entry
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)
+     * @param int $specificLifetime if != false, set a specific lifetime for this cache record (null => infinite lifetime)
      * @return boolean true if no problem
      */
-    public function save($data, $id, $tags = array(), $specificLifeTime = false)
+    public function save($data, $id, $tags = array(), $specificLifetime = false)
     {
         $this->_addLog('save', array($data, $id, $tags));
         if ($id=='false') {
@@ -160,17 +160,17 @@
         }
         return true;
     }
-    
+
     /**
      * Remove a cache record
-     * 
+     *
      * For this test backend only, if $id == 'false', then the method will return false
      * (true else)
-     * 
+     *
      * @param string $id cache id
      * @return boolean true if no problem
      */
-    public function remove($id) 
+    public function remove($id)
     {
         $this->_addLog('remove', array($id));
         if ($id=='false') {
@@ -178,7 +178,7 @@
         }
         return true;
     }
-    
+
     /**
      * Clean some cache records
      *
@@ -187,63 +187,63 @@
      *
      * Available modes are :
      * Zend_Cache::CLEANING_MODE_ALL (default)    => remove all cache entries ($tags is not used)
-     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used) 
-     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags 
-     *                                               ($tags can be an array of strings or a single string) 
+     * Zend_Cache::CLEANING_MODE_OLD              => remove too old cache entries ($tags is not used)
+     * Zend_Cache::CLEANING_MODE_MATCHING_TAG     => remove cache entries matching all given tags
+     *                                               ($tags can be an array of strings or a single string)
      * Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG => remove cache entries not {matching one of the given tags}
-     *                                               ($tags can be an array of strings or a single string)       
-     * 
+     *                                               ($tags can be an array of strings or a single string)
+     *
      * @param string $mode clean mode
      * @param tags array $tags array of tags
      * @return boolean true if no problem
      */
-    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array()) 
+    public function clean($mode = Zend_Cache::CLEANING_MODE_ALL, $tags = array())
     {
         $this->_addLog('clean', array($mode, $tags));
         if ($mode=='false') {
             return false;
         }
         return true;
-    }  
-    
+    }
+
     /**
      * Get the last log
-     * 
+     *
      * @return string the last log
      */
     public function getLastLog()
     {
         return $this->_log[$this->_index - 1];
     }
-    
+
     /**
      * Get the log index
-     * 
+     *
      * @return int log index
      */
     public function getLogIndex()
     {
         return $this->_index;
     }
-    
+
     /**
      * Get the complete log array
-     * 
+     *
      * @return array complete log array
      */
     public function getAllLogs()
     {
         return $this->_log;
     }
-    
-         
+
+
     // -----------------------
     // --- Private methods ---
     // -----------------------
-    
+
     /**
      * Add an event to the log array
-     * 
+     *
      * @param string $methodName methodName
      * @param array $args arguments
      */
@@ -254,6 +254,6 @@
             'args' => $args
         );
         $this->_index = $this->_index + 1;
-    }  
-    
+    }
+
 }
Index: library/Zend/Cache/Backend/ZendPlatform.php
===================================================================
--- library/Zend/Cache/Backend/ZendPlatform.php	(revision 3549)
+++ library/Zend/Cache/Backend/ZendPlatform.php	(working copy)
@@ -41,8 +41,8 @@
     // --- Constants ---
     // -----------------
     const TAGS_PREFIX = "internal_ZPtag:";
-    
-    
+
+
     // ----------------------
     // --- Public methods ---
     // ----------------------
@@ -72,7 +72,7 @@
         if (!is_writable($accConf['output_cache_dir'])) {
             Zend_Cache::throwException('The cache copies directory \''. ini_get('zend_accelerator.output_cache_dir') .'\' must be writable !');
         }
-        parent:: __construct($options);       
+        parent:: __construct($options);
     }
 
     /**
@@ -84,13 +84,13 @@
      */
     public function load($id, $doNotTestCacheValidity = false)
     {
-        // doNotTestCacheValidity implemented by giving zero lifetime to the cache
+        // doNotTestCacheValidity implemented by giving zero Lifetime to the cache
         if ($doNotTestCacheValidity) {
-            $lifeTime = 0;
+            $lifetime = 0;
         } else {
-            $lifeTime = $this->_directives['lifeTime'];
+            $lifetime = $this->_directives['lifetime'];
         }
-        $res = output_cache_get($id, $lifeTime);
+        $res = output_cache_get($id, $lifetime);
         if($res) {
             return $res[0];
         } else {
@@ -107,7 +107,7 @@
      */
     public function test($id)
     {
-        $result = output_cache_get($id, $this->_directives['lifeTime']);
+        $result = output_cache_get($id, $this->_directives['lifetime']);
         if ($result) {
             return $result[1];
         }
@@ -123,21 +123,21 @@
      * @param string $data data to cache
      * @param string $id cache id
      * @param array $tags array of strings, the cache record will be tagged by each string entry
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)
+     * @param int $specificLifeTime if != false, set a specific Lifetime for this cache record (null => infinite lifetime)
      * @return boolean true if no problem
      */
     public function save($data, $id, $tags = array(), $specificLifeTime = false)
     {
         if (!($specificLifeTime === false)) {
             if ($this->_directives['logging']) {
-                Zend_Log::log("Zend_Cache_Backend_ZendPlatform::save() : non false specifc lifeTime is unsuported for this backend", Zend_Log::LEVEL_WARNING);
+                Zend_Log::log("Zend_Cache_Backend_ZendPlatform::save() : non false specifc lifetime is unsuported for this backend", Zend_Log::LEVEL_WARNING);
             }
         }
-        $lifeTime = $this->_directives['lifeTime'];
+        $lifetime = $this->_directives['lifetime'];
         $result1 = output_cache_put($id, array($data, time()));
         foreach($tags as $tag) {
             $tagid = self::TAGS_PREFIX.$tag;
-            $old_tags = output_cache_get($tagid, $lifeTime);
+            $old_tags = output_cache_get($tagid, $lifetime);
             if ($old_tags === false) {
                 $old_tags = array();
             }
@@ -183,7 +183,7 @@
         if ($mode==Zend_Cache::CLEANING_MODE_MATCHING_TAG) {
             $idlist = null;
             foreach ($tags as $tag) {
-                $next_idlist = output_cache_get(self::TAGS_PREFIX.$tag, $this->_directives['lifeTime']);
+                $next_idlist = output_cache_get(self::TAGS_PREFIX.$tag, $this->_directives['lifetime']);
                 if ($idlist) {
                     $idlist = array_intersect_assoc($idlist, $next_idlist);
                 } else {
@@ -248,9 +248,9 @@
                 if ($mode == Zend_Cache::CLEANING_MODE_ALL) {
                     $result = ($this->_remove($file)) && ($result);
                 } else if ($mode == Zend_Cache::CLEANING_MODE_OLD) {
-                    // Files older than lifeTime get deleted from cache
-                    if (!is_null($this->_directives['lifeTime'])) {
-                        if ((time() - @filemtime($file)) > $this->_directives['lifeTime']) {
+                    // Files older than lifetime get deleted from cache
+                    if (!is_null($this->_directives['lifetime'])) {
+                        if ((time() - @filemtime($file)) > $this->_directives['lifetime']) {
                             $result = ($this->_remove($file)) && ($result);
                         }
                     }
@@ -278,13 +278,13 @@
             if ($this->_directives['logging']) {
                 Zend_Log::log("Zend_Cache_Backend_ZendPlatform::_remove() : we can't remove $file => we are going to try to invalidate it", Zend_Log::LEVEL_WARNING);
             }
-            if (is_null($this->_directives['lifeTime'])) {
+            if (is_null($this->_directives['lifetime'])) {
                 return false;
             }
             if (!file_exists($file)) {
                 return false;
             }
-            return @touch($file, time() - 2*abs($this->_directives['lifeTime']));
+            return @touch($file, time() - 2*abs($this->_directives['lifetime']));
         }
         return true;
     }
Index: library/Zend/Cache/Core.php
===================================================================
--- library/Zend/Cache/Core.php	(revision 3549)
+++ library/Zend/Cache/Core.php	(working copy)
@@ -25,24 +25,24 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
-class Zend_Cache_Core 
+class Zend_Cache_Core
 {
-    
+
     // ------------------
     // --- Properties ---
     // ------------------
-    
+
     /**
      * Backend Object
-     * 
+     *
      * @var object
      */
     private $_backend = null;
-    
+
     /**
      * Available options
-     * 
-     * ====> (boolean) writeControl :  
+     *
+     * ====> (boolean) writeControl :
      * - Enable / disable write control (the cache is read just after writing to detect corrupt entries)
      * - Enable write control will lightly slow the cache writing but not the cache reading
      * Write control can detect some corrupt cache files but maybe it's not a perfect control
@@ -50,77 +50,77 @@
      * ====> (boolean) caching :
      * - Enable / disable caching
      * (can be very usefull for the debug of cached scripts)
-     * 
+     *
      * ====> (boolean) automaticSerialization :
      * - Enable / disable automatic serialization
      * - It can be used to save directly datas which aren't strings (but it's slower)
-     * 
+     *
      * ====> (int) automaticCleaningFactor :
      * - Disable / Tune the automatic cleaning process
      * - The automatic cleaning process destroy too old (for the given life time)
      *   cache files when a new cache file is written :
      *     0               => no automatic cache cleaning
      *     1               => systematic cache cleaning
-     *     x (integer) > 1 => automatic cleaning randomly 1 times on x cache write    
+     *     x (integer) > 1 => automatic cleaning randomly 1 times on x cache write
      *
-     * ====> (int) lifeTime :
+     * ====> (int) Lifetime :
      * - Cache lifetime (in seconds)
      * - If null, the cache is valid forever.
-     * 
+     *
      * ====> (boolean) logging :
      * - If set to true, logging is activated (but the system is slower)
-     * 
+     *
      * @var array available options
      */
     protected $_options = array(
-        'writeControl' => true, 
-        'caching' => true, 
+        'writeControl' => true,
+        'caching' => true,
         'automaticSerialization' => false,
         'automaticCleaningFactor' => 10,
-        'lifeTime' => 3600,
+        'Lifetime' => 3600,
         'logging' => false
-    ); 
-    
+    );
+
     /**
      * Array of options which have to be transfered to backend
      */
-    protected static $_directivesList = array('lifeTime', 'logging');
-    
+    protected static $_directivesList = array('Lifetime', 'logging');
+
     /**
      * Not used for the core, just a sort a hint to get a common setOption() method (for the core and for frontends)
      */
     protected $_specificOptions = array();
-               
+
     /**
      * Last used cache id
-     * 
+     *
      * @var string $_lastId
      */
     private $_lastId = null;
 
-    
+
     // ----------------------
     // --- Public methods ---
     // ----------------------
-     
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
     {
         if (!is_array($options)) {
             Zend_Cache::throwException('Options parameter must be an array');
-        }  
+        }
         while (list($name, $value) = each($options)) {
             $this->_setOption($name, $value);
         }
     }
-    
+
     /**
-     * Set the backend 
-     * 
+     * Set the backend
+     *
      * @param object $backendObject
      */
     public function setBackend($backendObject)
@@ -130,19 +130,19 @@
         }
         $this->_backend= $backendObject;
         // some options (listed in $_directivesList) have to be given
-        // to the backend too (even if they are not "backend specific") 
+        // to the backend too (even if they are not "backend specific")
         $directives = array();
         foreach (Zend_Cache_Core::$_directivesList as $directive) {
             $directives[$directive] = $this->_options[$directive];
         }
         $this->_backend->setDirectives($directives);
     }
-    
+
     /**
      * Public frontend to set an option
-     * 
-     * There is an additional validation (relatively to the protected _setOption method) 
-     * 
+     *
+     * There is an additional validation (relatively to the protected _setOption method)
+     *
      * @param string $name name of the option
      * @param mixed $value value of the option
      */
@@ -154,18 +154,18 @@
                 $this->_setOption($name, $value);
                 return;
             }
-            if (array_key_exists($name, $this->_specificOptions)) { 
+            if (array_key_exists($name, $this->_specificOptions)) {
                 // This a specic option of this frontend
                 $this->_specificOptions[$name] = $value;
                 return;
             }
-        } 
+        }
         Zend_Cache::throwException("Incorrect option name : $name");
     }
-    
+
     /**
      * Set an option
-     * 
+     *
      * @param string $name name of the option
      * @param mixed $value value of the option
      */
@@ -177,29 +177,29 @@
         $this->_options[$name] = $value;
         if ($name=='logging') {
             if ((!class_exists('Zend_Log', false)) && ($value)) {
-                Zend_Cache::throwException('logging feature is on but Zend_Log is not "loaded"');    
+                Zend_Cache::throwException('logging feature is on but Zend_Log is not "loaded"');
             }
         }
     }
-    
+
     /**
      * Force a new lifetime
-     * 
+     *
      * The new value is set for the core/frontend but for the backend too (directive)
-     * 
+     *
      * @param int $newLifeTime new lifetime (in seconds)
      */
     public function setLifeTime($newLifeTime)
     {
-        $this->_options['lifeTime'] = $newLifeTime;
+        $this->_options['Lifetime'] = $newLifeTime;
         $this->_backend->setDirectives(array(
-            'lifeTime' => $newLifeTime
+            'Lifetime' => $newLifeTime
         ));
     }
-    
+
     /**
      * Test if a cache is available for the given id and (if yes) return it (false else)
-     * 
+     *
      * @param string $id cache id
      * @param boolean $doNotTestCacheValidity if set to true, the cache validity won't be tested
      * @param boolean $doNotUnserialize do not serialize (even if automaticSerialization is true) => for internal use
@@ -210,7 +210,7 @@
         if (!$this->_options['caching']) {
             return false;
         }
-        $this->_lastId = $id;        
+        $this->_lastId = $id;
         self::_validateIdOrTag($id);
         $data = $this->_backend->load($id, $doNotTestCacheValidity);
         if ($data===false) {
@@ -223,7 +223,7 @@
         }
         return $data;
     }
-    
+
     /**
      * THIS METHOD IS DEPRECATED : USE LOAD() INSTEAD (same syntax) !
      */
@@ -234,14 +234,14 @@
         }
         return $this->load($id, $doNotTestCacheValidity, $doNotUnserialize);
     }
-    
+
     /**
-     * Test if a cache is available for the given id 
+     * Test if a cache is available for the given id
      *
      * @param string $id cache id
      * @return boolean true is a cache is available, false else
      */
-    public function test($id) 
+    public function test($id)
     {
         if (!$this->_options['caching']) {
             return false;
@@ -250,17 +250,17 @@
         $this->_lastId = $id;
         return $this->_backend->test($id);
     }
-    
+
     /**
-     * Save some data in a cache 
-     * 
+     * Save some data in a cache
+     *
      * @param mixed $data data to put in cache (can be another type than string if automaticSerialization is on)
      * @param cache $id cache id (if not set, the last cache id will be used)
      * @param array $tags cache tags
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)
+     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite Lifetime)
      * @return boolean true if no problem
      */
-    public function save($data, $id = null, $tags = array(), $specificLifeTime = false) 
+    public function save($data, $id = null, $tags = array(), $specificLifeTime = false)
     {
         if (!$this->_options['caching']) {
             return true;
@@ -268,8 +268,8 @@
         if (is_null($id)) {
             $id = $this->_lastId;
         }
-        self::_validateIdOrTag($id);  
-        self::_validateTagsArray($tags);   
+        self::_validateIdOrTag($id);
+        self::_validateTagsArray($tags);
         if ($this->_options['automaticSerialization']) {
             // we need to serialize datas before storing them
             $data = serialize($data);
@@ -278,7 +278,7 @@
                 Zend_Cache::throwException("Datas must be string or set automaticSerialization = true");
             }
         }
-        // automatic cleaning 
+        // automatic cleaning
         if ($this->_options['automaticCleaningFactor'] > 0) {
             $rand = rand(1, $this->_options['automaticCleaningFactor']);
             if ($rand==1) {
@@ -306,10 +306,10 @@
         }
         return true;
     }
-    
+
     /**
-     * Remove a cache 
-     * 
+     * Remove a cache
+     *
      * @param string $id cache id to remove
      * @return boolean true if ok
      */
@@ -321,20 +321,20 @@
         self::_validateIdOrTag($id);
         return $this->_backend->remove($id);
     }
-    
+
     /**
      * Clean cache entries
-     * 
+     *
      * Available modes are :
      * 'all' (default)  => remove all cache entries ($tags is not used)
-     * 'old'            => remove too old cache entries ($tags is not used) 
-     * 'matchingTag'    => remove cache entries matching all given tags 
-     *                     ($tags can be an array of strings or a single string) 
+     * 'old'            => remove too old cache entries ($tags is not used)
+     * 'matchingTag'    => remove cache entries matching all given tags
+     *                     ($tags can be an array of strings or a single string)
      * 'notMatchingTag' => remove cache entries not matching one of the given tags
-     *                     ($tags can be an array of strings or a single string)                            
-     * 
+     *                     ($tags can be an array of strings or a single string)
+     *
      * @param string $mode
-     * @param mixed $parameters  
+     * @param mixed $parameters
      * @return boolean true if ok
      */
     public function clean($mode = 'all', $tags = array())
@@ -348,16 +348,16 @@
         self::_validateTagsArray($tags);
         return $this->_backend->clean($mode, $tags);
     }
-       
+
     // ------------------------------------
     // --- Private or protected methods ---
     // ------------------------------------
-       
+
     /**
      * Validate a cache id or a tag (security, reliable filenames, reserved prefixes...)
-     * 
+     *
      * Throw an exception if a problem is found
-     * 
+     *
      * @param string $string cache id or tag
      */
     private static function _validateIdOrTag($string)
@@ -372,12 +372,12 @@
             Zend_Cache::throwException('Invalid id or tag : must use only [a-zA-Z0-9_]');
         }
     }
-    
+
     /**
      * Validate a tags array (security, reliable filenames, reserved prefixes...)
-     * 
+     *
      * Throw an exception if a problem is found
-     * 
+     *
      * @param array $tags array of tags
      */
     private static function _validateTagsArray($tags)
@@ -390,5 +390,5 @@
         }
         reset($tags);
     }
-             
+
 }
Index: library/Zend/Cache/Frontend/Class.php
===================================================================
--- library/Zend/Cache/Frontend/Class.php	(revision 3549)
+++ library/Zend/Cache/Frontend/Class.php	(working copy)
@@ -19,7 +19,7 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
- 
+
 /**
  * Zend_Cache_Core
  */
@@ -34,27 +34,27 @@
  */
 class Zend_Cache_Frontend_Class extends Zend_Cache_Core
 {
-       
+
     // ------------------
     // --- Properties ---
-    // ------------------  
-    
+    // ------------------
+
     /**
      * Available options
-     * 
+     *
      * ====> (mixed) cachedEntity :
      * - if set to a class name, we will cache an abstract class and will use only static calls
      * - if set to an object, we will cache this object methods
-     * 
-     * ====> (boolean) cacheByDefault : 
+     *
+     * ====> (boolean) cacheByDefault :
      * - if true, method calls will be cached by default
-     * 
+     *
      * ====> (array) cachedMethods :
      * - an array of method names which will be cached (even if cacheByDefault = false)
-     * 
+     *
      * ====> (array) nonCachedMethods :
      * - an array of method names which won't be cached (even if cacheByDefault = true)
-     * 
+     *
      * @var array available options
      */
     protected $_specificOptions = array(
@@ -63,38 +63,38 @@
         'cachedMethods' => array(),
         'nonCachedMethods' => array()
     );
-    
+
     /**
      * Tags array
-     * 
+     *
      * @var array
      */
     private $_tags = array();
-    
+
     /**
-     * SpecificLifeTime value
-     * 
+     * SpecificLifetime value
+     *
      * false => no specific life time
-     * 
+     *
      * @var int
      */
-    private $_specificLifeTime = false;
-            
+    private $_specificLifetime = false;
+
     /**
      * The cached object or the name of the cached abstract class
-     * 
+     *
      * @var mixed
      */
     private $_cachedEntity = null;
-    
-    
+
+
     // ----------------------
     // --- Public methods ---
     // ----------------------
-       
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
@@ -111,36 +111,36 @@
             $this->setOption($name, $value);
         }
         $this->setOption('automaticSerialization', true);
-    }    
-    
+    }
+
     /**
-     * Set a specific life time
-     * 
-     * @param int $specificLifeTime 
+     * Set a specific lifetime
+     *
+     * @param int $specificLifetime
      */
-    public function setSpecificLifeTime($specificLifeTime = false)
+    public function setSpecificLifetime($specificLifetime = false)
     {
-        $this->_specificLifeTime = $specificLifeTime;
+        $this->_specificLifetime = $specificLifetime;
     }
-    
+
     /**
      * Set the cache array
-     * 
+     *
      * @param array $tags
      */
     public function setTagsArray($tags = array())
     {
         $this->_tags = $tags;
     }
-    
+
     /**
      * Main method : call the specified method or get the result from cache
-     * 
+     *
      * @param string $name method name
      * @param array $parameters method parameters
      * @return mixed result
      */
-    public function __call($name, $parameters) 
+    public function __call($name, $parameters)
     {
         $cacheBool1 = $this->_specificOptions['cacheByDefault'];
         $cacheBool2 = in_array($name, $this->_specificOptions['cachedMethods']);
@@ -150,12 +150,12 @@
             // We do not have not cache
             return call_user_func_array(array($this->_cachedEntity, $name), $parameters);
         }
-        $id = $this->_makeId($name, $parameters);       
+        $id = $this->_makeId($name, $parameters);
         if ($this->test($id)) {
             // A cache is available
             $result = $this->load($id);
             $output = $result[0];
-            $return = $result[1];                      
+            $return = $result[1];
         } else {
             // A cache is not available
             ob_start();
@@ -164,27 +164,27 @@
             $output = ob_get_contents();
             ob_end_clean();
             $data = array($output, $return);
-            $this->save($data, $id, $this->_tags, $this->_specificLifeTime);
+            $this->save($data, $id, $this->_tags, $this->_specificLifetime);
         }
         echo $output;
         return $return;
     }
-    
-    
+
+
     // ------------------------------------
     // --- Private or protected methods ---
     // ------------------------------------
-    
+
     /**
      * Make a cache id from the method name and parameters
-     * 
+     *
      * @param string $name method name
      * @param array $parameters method parameters
      * @return string cache id
-     */        
-    private function _makeId($name, $parameters) 
+     */
+    private function _makeId($name, $parameters)
     {
         return md5($name . serialize($parameters));
     }
-                 
+
 }
Index: library/Zend/Cache/Frontend/Function.php
===================================================================
--- library/Zend/Cache/Frontend/Function.php	(revision 3549)
+++ library/Zend/Cache/Frontend/Function.php	(working copy)
@@ -20,7 +20,7 @@
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
 
- 
+
 /**
  * Zend_Cache_Core
  */
@@ -35,39 +35,39 @@
  */
 class Zend_Cache_Frontend_Function extends Zend_Cache_Core
 {
-       
+
     // ------------------
     // --- Properties ---
-    // ------------------     
-       
+    // ------------------
+
     /**
      * This frontend specific options
-     * 
-     * ====> (boolean) cacheByDefault : 
+     *
+     * ====> (boolean) cacheByDefault :
      * - if true, function calls will be cached by default
-     * 
+     *
      * ====> (array) cachedFunctions :
      * - an array of function names which will be cached (even if cacheByDefault = false)
-     * 
+     *
      * ====> (array) nonCachedFunctions :
      * - an array of function names which won't be cached (even if cacheByDefault = true)
-     * 
+     *
      * @var array options
      */
     protected $_specificOptions = array(
-        'cacheByDefault' => true, 
+        'cacheByDefault' => true,
         'cachedFunctions' => array(),
         'nonCachedFunctions' => array()
-    ); 
-    
-    
+    );
+
+
     // ----------------------
     // --- Public methods ---
-    // ----------------------             
-           
+    // ----------------------
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
@@ -76,18 +76,18 @@
             $this->setOption($name, $value);
         }
         $this->setOption('automaticSerialization', true);
-    }    
-        
+    }
+
     /**
      * Main method : call the specified function or get the result from cache
-     * 
+     *
      * @param string $name function name
      * @param array $parameters function parameters
      * @param array $tags cache tags
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)    
+     * @param int $specificLifetime if != false, set a specific lifetime for this cache record (null => infinite lifetime)
      * @return mixed result
      */
-    public function call($name, $parameters = array(), $tags = array(), $specificLifeTime = false) 
+    public function call($name, $parameters = array(), $tags = array(), $specificLifetime = false)
     {
         $cacheBool1 = $this->_specificOptions['cacheByDefault'];
         $cacheBool2 = in_array($name, $this->_specificOptions['cachedFunctions']);
@@ -104,32 +104,32 @@
             $output = $result[0];
             $return = $result[1];
         } else {
-            // A cache is not available 
+            // A cache is not available
             ob_start();
             ob_implicit_flush(false);
             $return = call_user_func_array($name, $parameters);
             $output = ob_get_contents();
             ob_end_clean();
             $data = array($output, $return);
-            $this->save($data, $id, $tags, $specificLifeTime);
+            $this->save($data, $id, $tags, $specificLifetime);
         }
         echo $output;
         return $return;
     }
 
-    
+
     // ------------------------------------
     // --- Private or protected methods ---
     // ------------------------------------
-    
+
     /**
      * Make a cache id from the function name and parameters
-     * 
+     *
      * @param string $name function name
      * @param array $parameters function parameters
      * @return string cache id
-     */    
-    private function _makeId($name, $parameters) 
+     */
+    private function _makeId($name, $parameters)
     {
         if (!is_string($name)) {
             Zend_Cache::throwException('Incorrect function name');
@@ -139,5 +139,5 @@
         }
         return md5($name . serialize($parameters));
     }
-                 
+
 }
Index: library/Zend/Cache/Frontend/Output.php
===================================================================
--- library/Zend/Cache/Frontend/Output.php	(revision 3549)
+++ library/Zend/Cache/Frontend/Output.php	(working copy)
@@ -19,8 +19,8 @@
  * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
  * @license    http://framework.zend.com/license/new-bsd     New BSD License
  */
- 
- 
+
+
 /**
  * Zend_Cache_Core
  */
@@ -35,18 +35,18 @@
  */
 class Zend_Cache_Frontend_Output extends Zend_Cache_Core
 {
-                 
+
     /**
      * Constructor
-     * 
+     *
      * @param array $options associative array of options
      */
     public function __construct($options = array())
     {
         parent::__construct($options);
     }
-        
-        
+
+
     /**
      * Start the cache
      *
@@ -69,17 +69,17 @@
 
     /**
      * Stop the cache
-     * 
+     *
      * @param array $tags tags array
-     * @param int $specificLifeTime if != false, set a specific lifetime for this cache record (null => infinite lifeTime)    
+     * @param int $specificLifetime if != false, set a specific lifetime for this cache record (null => infinite lifetime)
      */
-    public function end($tags = array(), $specificLifeTime = false)
+    public function end($tags = array(), $specificLifetime = false)
     {
         $data = ob_get_contents();
         ob_end_clean();
-        $this->save($data, null, $tags, $specificLifeTime);
+        $this->save($data, null, $tags, $specificLifetime);
         echo($data);
     }
-             
+
 }
 
