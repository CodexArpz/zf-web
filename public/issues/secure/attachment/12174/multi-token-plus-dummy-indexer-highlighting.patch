Index: Search/Lucene/TempIndex.php
===================================================================
--- Search/Lucene/TempIndex.php	(Revision 0)
+++ Search/Lucene/TempIndex.php	(Revision 0)
@@ -0,0 +1,687 @@
+<?php
+/**
+ * Zend Framework
+ *
+ * LICENSE
+ *
+ * This source file is subject to the new BSD license that is bundled
+ * with this package in the file LICENSE.txt.
+ * It is also available through the world-wide-web at this URL:
+ * http://framework.zend.com/license/new-bsd
+ * If you did not receive a copy of the license and are unable to
+ * obtain it through the world-wide-web, please send an email
+ * to license@zend.com so we can send you a copy immediately.
+ *
+ * @category   Zend
+ * @package    Zend_Search_Lucene
+ * @copyright  Copyright (c) 2005-2009 Zend Technologies USA Inc. (http://www.zend.com)
+ * @license    http://framework.zend.com/license/new-bsd     New BSD License
+ * @version    $Id: Lucene.php 17840 2009-08-27 13:42:06Z alexander $
+ */
+
+/** Zend_Search_Lucene_Interface */
+require_once 'Zend/Search/Lucene/Interface.php';
+
+/** Zend_Search_Lucene_Document */
+require_once 'Zend/Search/Lucene/Document.php';
+
+/** Zend_Search_Lucene_Index_Term */
+require_once 'Zend/Search/Lucene/Index/Term.php';
+
+/** Zend_Search_Lucene_Analysis_Token */
+require_once 'Zend/Search/Lucene/Analysis/Token.php';
+
+
+
+/**
+ * @category   Zend
+ * @package    Zend_Search_Lucene
+ * @copyright  Copyright (c) 2005-2009 Zend Technologies USA Inc. (http://www.zend.com)
+ * @license    http://framework.zend.com/license/new-bsd     New BSD License
+ */
+class Zend_Search_Lucene_TempIndex implements Zend_Search_Lucene_Interface
+{
+
+    /**
+     * document ID
+     * @var integer
+     */
+    private $_docID = 0;
+
+    /**
+     * stored 'indexed' documents
+     * @var array
+     */
+    private $_documents = array();
+
+    /**
+     * stored 'indexed' fields
+     * @var array
+     */
+    private $_fields = array();
+
+    /**
+     * field for current simulated term stream
+     * @var string
+     */
+    private $_currentField = '';
+
+    /**
+     * stored 'indexed' terms
+     * (sorted by fieldname and text string)
+     * @var array
+     */
+    private $_terms = array();
+
+    /**
+     * Get current generation number
+     *
+     * Returns generation number
+     * 0 means pre-2.1 index format
+     * -1 means there are no segments files.
+     *
+     * @param Zend_Search_Lucene_Storage_Directory $directory
+     * @return integer
+     * @throws Zend_Search_Lucene_Exception
+     */
+    public static function getActualGeneration(Zend_Search_Lucene_Storage_Directory $directory)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Get segments file name
+     *
+     * @param integer $generation
+     * @return string
+     */
+    public static function getSegmentFileName($generation)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Get index format version
+     *
+     * @return integer
+     */
+    public function getFormatVersion()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Set index format version.
+     * Index is converted to this format at the nearest upfdate time
+     *
+     * @param int $formatVersion
+     * @throws Zend_Search_Lucene_Exception
+     */
+    public function setFormatVersion($formatVersion)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns the Zend_Search_Lucene_Storage_Directory instance for this index.
+     *
+     * @return Zend_Search_Lucene_Storage_Directory
+     */
+    public function getDirectory()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns the total number of documents in this index (including deleted documents).
+     *
+     * @return integer
+     */
+    public function count()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns one greater than the largest possible document number.
+     * This may be used to, e.g., determine how big to allocate a structure which will have
+     * an element for every document number in an index.
+     *
+     * @return integer
+     */
+    public function maxDoc()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns the total number of non-deleted documents in this index.
+     *
+     * @return integer
+     */
+    public function numDocs()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Checks, that document is deleted
+     *
+     * @param integer $id
+     * @return boolean
+     * @throws Zend_Search_Lucene_Exception    Exception is thrown if $id is out of the range
+     */
+    public function isDeleted($id)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Set default search field.
+     *
+     * Null means, that search is performed through all fields by default
+     *
+     * Default value is null
+     *
+     * @param string $fieldName
+     */
+    public static function setDefaultSearchField($fieldName)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Get default search field.
+     *
+     * Null means, that search is performed through all fields by default
+     *
+     * @return string
+     */
+    public static function getDefaultSearchField()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Set result set limit.
+     *
+     * 0 (default) means no limit
+     *
+     * @param integer $limit
+     */
+    public static function setResultSetLimit($limit)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Set result set limit.
+     *
+     * 0 means no limit
+     *
+     * @return integer
+     */
+    public static function getResultSetLimit()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Retrieve index maxBufferedDocs option
+     *
+     * maxBufferedDocs is a minimal number of documents required before
+     * the buffered in-memory documents are written into a new Segment
+     *
+     * Default value is 10
+     *
+     * @return integer
+     */
+    public function getMaxBufferedDocs()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Set index maxBufferedDocs option
+     *
+     * maxBufferedDocs is a minimal number of documents required before
+     * the buffered in-memory documents are written into a new Segment
+     *
+     * Default value is 10
+     *
+     * @param integer $maxBufferedDocs
+     */
+    public function setMaxBufferedDocs($maxBufferedDocs)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Retrieve index maxMergeDocs option
+     *
+     * maxMergeDocs is a largest number of documents ever merged by addDocument().
+     * Small values (e.g., less than 10,000) are best for interactive indexing,
+     * as this limits the length of pauses while indexing to a few seconds.
+     * Larger values are best for batched indexing and speedier searches.
+     *
+     * Default value is PHP_INT_MAX
+     *
+     * @return integer
+     */
+    public function getMaxMergeDocs()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Set index maxMergeDocs option
+     *
+     * maxMergeDocs is a largest number of documents ever merged by addDocument().
+     * Small values (e.g., less than 10,000) are best for interactive indexing,
+     * as this limits the length of pauses while indexing to a few seconds.
+     * Larger values are best for batched indexing and speedier searches.
+     *
+     * Default value is PHP_INT_MAX
+     *
+     * @param integer $maxMergeDocs
+     */
+    public function setMaxMergeDocs($maxMergeDocs)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Retrieve index mergeFactor option
+     *
+     * mergeFactor determines how often segment indices are merged by addDocument().
+     * With smaller values, less RAM is used while indexing,
+     * and searches on unoptimized indices are faster,
+     * but indexing speed is slower.
+     * With larger values, more RAM is used during indexing,
+     * and while searches on unoptimized indices are slower,
+     * indexing is faster.
+     * Thus larger values (> 10) are best for batch index creation,
+     * and smaller values (< 10) for indices that are interactively maintained.
+     *
+     * Default value is 10
+     *
+     * @return integer
+     */
+    public function getMergeFactor()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Set index mergeFactor option
+     *
+     * mergeFactor determines how often segment indices are merged by addDocument().
+     * With smaller values, less RAM is used while indexing,
+     * and searches on unoptimized indices are faster,
+     * but indexing speed is slower.
+     * With larger values, more RAM is used during indexing,
+     * and while searches on unoptimized indices are slower,
+     * indexing is faster.
+     * Thus larger values (> 10) are best for batch index creation,
+     * and smaller values (< 10) for indices that are interactively maintained.
+     *
+     * Default value is 10
+     *
+     * @param integer $maxMergeDocs
+     */
+    public function setMergeFactor($mergeFactor)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Performs a query against the index and returns an array
+     * of Zend_Search_Lucene_Search_QueryHit objects.
+     * Input is a string or Zend_Search_Lucene_Search_Query.
+     *
+     * @param mixed $query
+     * @return array Zend_Search_Lucene_Search_QueryHit
+     * @throws Zend_Search_Lucene_Exception
+     */
+    public function find($query)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns a list of all unique field names that exist in this index.
+     *
+     * @param boolean $indexed
+     * @return array
+     */
+    public function getFieldNames($indexed = false)
+    {
+        return array_keys($this->_fields);
+    }
+
+    /**
+     * Returns a Zend_Search_Lucene_Document object for the document
+     * number $id in this index.
+     *
+     * @param integer|Zend_Search_Lucene_Search_QueryHit $id
+     * @return Zend_Search_Lucene_Document
+     */
+    public function getDocument($id)
+    {
+        return $this->_documents[$id];
+    }
+
+    /**
+     * Returns true if index contain documents with specified term.
+     *
+     * Is used for query optimization.
+     *
+     * @param Zend_Search_Lucene_Index_Term $term
+     * @return boolean
+     */
+    public function hasTerm(Zend_Search_Lucene_Index_Term $term)
+    {
+        if (isset($this->_terms[$term->field][$terms->text])) return true;
+        return false;
+    }
+
+    /**
+     * Returns IDs of all the documents containing term.
+     *
+     * @param Zend_Search_Lucene_Index_Term $term
+     * @param Zend_Search_Lucene_Index_DocsFilter|null $docsFilter
+     * @return array
+     */
+    public function termDocs(Zend_Search_Lucene_Index_Term $term, $docsFilter = null)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns documents filter for all documents containing term.
+     *
+     * It performs the same operation as termDocs, but return result as
+     * Zend_Search_Lucene_Index_DocsFilter object
+     *
+     * @param Zend_Search_Lucene_Index_Term $term
+     * @param Zend_Search_Lucene_Index_DocsFilter|null $docsFilter
+     * @return Zend_Search_Lucene_Index_DocsFilter
+     */
+    public function termDocsFilter(Zend_Search_Lucene_Index_Term $term, $docsFilter = null)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns an array of all term freqs.
+     * Return array structure: array( docId => freq, ...)
+     *
+     * @param Zend_Search_Lucene_Index_Term $term
+     * @param Zend_Search_Lucene_Index_DocsFilter|null $docsFilter
+     * @return integer
+     */
+    public function termFreqs(Zend_Search_Lucene_Index_Term $term, $docsFilter = null)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns an array of all term positions in the documents.
+     * Return array structure: array( docId => array( pos1, pos2, ...), ...)
+     *
+     * @param Zend_Search_Lucene_Index_Term $term
+     * @param Zend_Search_Lucene_Index_DocsFilter|null $docsFilter
+     * @return array
+     */
+    public function termPositions(Zend_Search_Lucene_Index_Term $term, $docsFilter = null)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns the number of documents in this index containing the $term.
+     *
+     * @param Zend_Search_Lucene_Index_Term $term
+     * @return integer
+     */
+    public function docFreq(Zend_Search_Lucene_Index_Term $term)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Retrive similarity used by index reader
+     *
+     * @return Zend_Search_Lucene_Search_Similarity
+     */
+    public function getSimilarity()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns a normalization factor for "field, document" pair.
+     *
+     * @param integer $id
+     * @param string $fieldName
+     * @return float
+     */
+    public function norm($id, $fieldName)
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns true if any documents have been deleted from this index.
+     *
+     * @return boolean
+     */
+    public function hasDeletions()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Deletes a document from the index.
+     * $id is an internal document id
+     *
+     * @param integer|Zend_Search_Lucene_Search_QueryHit $id
+     * @throws Zend_Search_Lucene_Exception
+     */
+    public function delete($id)
+    {
+        unset($this->_documents[$id]);
+    }
+
+    /**
+     * Adds a document to this index.
+     *
+     * @param Zend_Search_Lucene_Document $document
+     */
+    public function addDocument(Zend_Search_Lucene_Document $document)
+    {
+        $this->_documents[$this->_docID] = $document;
+
+        // parse document
+        $analyzer   = Zend_Search_Lucene_Analysis_Analyzer::getDefault();
+        $fieldNames = $document->getFieldnames();
+        foreach ($fieldNames as $fieldName) {
+            $field =  $document->getField($fieldName);
+            // tokenize if requested
+            if ($field->isTokenized) {
+                $tokens = $analyzer->tokenize($field->getUtf8Value(), 'UTF-8');
+            } else {
+                $tokens = array( new Zend_Search_Lucene_Analysis_Token($field->getUtf8Value(),0,strlen(utf8_decode($field->getUtf8Value()))) );
+            }
+            // store tokens in "index"
+            foreach( $tokens as $token ) {
+                $text = $token->getTermText();
+                $term = new Zend_Search_Lucene_Index_Term($text,$fieldName);
+                // one ordered array for each field name
+                if (isset($this->_terms[$fieldName])) {
+                    if (!isset($this->_terms[$fieldName][$text])) {
+                        $new=array();
+                        while (($current = array_shift($this->_terms[$fieldName])) && $text > $current->text) {
+                            $new[$current->text] = $current;
+                        }
+                        $new[$text] = $term;
+                        if ($current) $new[$current->text] = $current;
+                        $this->_terms[$fieldName] = array_merge($new,$this->_terms[$fieldName]);
+                    }
+                } else {
+                    $this->_terms[$fieldName][$text]=$term;
+                }
+            }
+            $this->_fields[$fieldName][$this->_docID] = $field;
+        }
+        $this->_docID++;
+    }
+
+    /**
+     * Commit changes resulting from delete() or undeleteAll() operations.
+     */
+    public function commit()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Optimize index.
+     *
+     * Merges all segments into one
+     */
+    public function optimize()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Returns an array of all terms in this index.
+     *
+     * @return array
+     */
+    public function terms()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Undeletes all documents currently marked as deleted in this index.
+     */
+    public function undeleteAll()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+
+    /**
+     * Add reference to the index object
+     *
+     * @internal
+     */
+    public function addReference()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+
+    /**
+     * Remove reference from the index object
+     *
+     * When reference count becomes zero, index is closed and resources are cleaned up
+     *
+     * @internal
+     */
+    public function removeReference()
+    {
+        require_once 'Zend/Search/Lucene/Exception.php';
+        throw new Zend_Search_Lucene_Exception('Unimplemented in TempIndex');
+    }
+    /**
+     * Reset terms stream.
+     */
+    public function resetTermsStream(){
+        reset($this->_terms);
+    }
+
+    /**
+     * Skip terms stream up to specified term preffix.
+     *
+     * Prefix contains fully specified field info and portion of searched term
+     *
+     * @param Zend_Search_Lucene_Index_Term $prefix
+     */
+    public function skipTo(Zend_Search_Lucene_Index_Term $prefix){
+        $field = $prefix->field;
+        $text  = $prefix->text;
+        if (!$this->_terms[$field]) return;
+        $this->_currentField = $field;
+        reset($this->_terms[$field]);
+        if (current($this->_terms[$field])->text<$text) {
+            while (current($this->_terms[$field])->text<$text) {
+                next($this->_terms[$field]);
+            };
+        }
+    }
+
+    /**
+     * Scans terms dictionary and returns next term
+     *
+     * @return Zend_Search_Lucene_Index_Term|null
+     */
+    public function nextTerm(){
+        if (!isset($this->_terms[$this->_currentField])) return null;
+        return next($this->_terms[$this->_currentField]);
+    }
+
+    /**
+     * Returns term in current position
+     *
+     * @return Zend_Search_Lucene_Index_Term|null
+     */
+    public function currentTerm(){
+        if (!isset($this->_terms[$this->_currentField])) return null;
+        return current($this->_terms[$this->_currentField]);
+    }
+
+    /**
+     * Close terms stream
+     *
+     * Should be used for resources clean up if stream is not read up to the end
+     */
+    public function closeTermsStream(){
+        return;
+    }
+}
Index: Search/Lucene/Search/Query.php
===================================================================
--- Search/Lucene/Search/Query.php	(Revision 17917)
+++ Search/Lucene/Search/Query.php	(Arbeitskopie)
@@ -29,6 +29,8 @@
 /** Zend_Search_Lucene_Search_Highlighter_Default */
 require_once 'Zend/Search/Lucene/Search/Highlighter/Default.php';
 
+/** Zend_Search_Lucene_TempIndex */
+require_once 'Zend/Search/Lucene/TempIndex.php';
 
 /**
  * @category   Zend
@@ -178,13 +180,6 @@
     abstract public function getQueryTerms();
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    abstract protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter);
-
-    /**
      * Highlight matches in $inputHTML
      *
      * @param string $inputHTML
@@ -198,10 +193,16 @@
             $highlighter = new Zend_Search_Lucene_Search_Highlighter_Default();
         }
 
+        $index = new Zend_Search_Lucene_TempIndex();
+
         $doc = Zend_Search_Lucene_Document_Html::loadHTML($inputHTML, false, $defaultEncoding);
         $highlighter->setDocument($doc);
+        $index->addDocument($doc);
 
-        $this->_highlightMatches($highlighter);
+        $terms = $this->rewrite($index)->getQueryTerms();
+        foreach ($terms as $term) {
+            $highlighter->highlight($term->text);
+        }
 
         return $doc->getHTML();
     }
@@ -223,12 +224,19 @@
         $inputHTML = '<html><head><META HTTP-EQUIV="Content-type" CONTENT="text/html; charset=UTF-8"/></head><body>'
                    . iconv($encoding, 'UTF-8//IGNORE', $inputHtmlFragment) . '</body></html>';
 
+        $index = new Zend_Search_Lucene_TempIndex();
+
         $doc = Zend_Search_Lucene_Document_Html::loadHTML($inputHTML);
         $highlighter->setDocument($doc);
+        $index->addDocument($doc);
 
-        $this->_highlightMatches($highlighter);
+        $terms = $this->rewrite($index)->getQueryTerms();
+        foreach ($terms as $term) {
+            $highlighter->highlight($term->text);
+        }
 
         return $doc->getHtmlBody();
     }
+
 }
 
Index: Search/Lucene/Search/Query/Wildcard.php
===================================================================
--- Search/Lucene/Search/Query/Wildcard.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Wildcard.php	(Arbeitskopie)
@@ -299,33 +299,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        $words = array();
-
-        $matchExpression = '/^' . str_replace(array('\\?', '\\*'), array('.', '.*') , preg_quote($this->_pattern->text, '/')) . '$/';
-        if (@preg_match('/\pL/u', 'a') == 1) {
-            // PCRE unicode support is turned on
-            // add Unicode modifier to the match expression
-            $matchExpression .= 'u';
-        }
-
-        $docBody = $highlighter->getDocument()->getFieldUtf8Value('body');
-        $tokens = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($docBody, 'UTF-8');
-        foreach ($tokens as $token) {
-            if (preg_match($matchExpression, $token->getTermText()) === 1) {
-                $words[] = $token->getTermText();
-            }
-        }
-
-        $highlighter->highlight($words);
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Range.php
===================================================================
--- Search/Lucene/Search/Query/Range.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Range.php	(Arbeitskopie)
@@ -319,42 +319,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        $words = array();
-
-        $docBody = $highlighter->getDocument()->getFieldUtf8Value('body');
-        $tokens = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($docBody, 'UTF-8');
-
-        $lowerTermText = ($this->_lowerTerm !== null)? $this->_lowerTerm->text : null;
-        $upperTermText = ($this->_upperTerm !== null)? $this->_upperTerm->text : null;
-
-        if ($this->_inclusive) {
-            foreach ($tokens as $token) {
-                $termText = $token->getTermText();
-                if (($lowerTermText == null  ||  $lowerTermText <= $termText)  &&
-                    ($upperTermText == null  ||  $termText <= $upperTermText)) {
-                    $words[] = $termText;
-                }
-            }
-        } else {
-            foreach ($tokens as $token) {
-                $termText = $token->getTermText();
-                if (($lowerTermText == null  ||  $lowerTermText < $termText)  &&
-                    ($upperTermText == null  ||  $termText < $upperTermText)) {
-                    $words[] = $termText;
-                }
-            }
-        }
-
-        $highlighter->highlight($words);
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Preprocessing/Phrase.php
===================================================================
--- Search/Lucene/Search/Query/Preprocessing/Phrase.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Preprocessing/Phrase.php	(Arbeitskopie)
@@ -212,40 +212,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        /** Skip fields detection. We don't need it, since we expect all fields presented in the HTML body and don't differentiate them */
-
-        /** Skip exact term matching recognition, keyword fields highlighting is not supported */
-
-        /** Skip wildcard queries recognition. Supported wildcards are removed by text analyzer */
-
-        // tokenize phrase using current analyzer and process it as a phrase query
-        $tokens = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($this->_phrase, $this->_phraseEncoding);
-
-        if (count($tokens) == 0) {
-            // Do nothing
-            return;
-        }
-
-        if (count($tokens) == 1) {
-            $highlighter->highlight($tokens[0]->getTermText());
-            return;
-        }
-
-        //It's non-trivial phrase query
-        $words = array();
-        foreach ($tokens as $token) {
-            $words[] = $token->getTermText();
-        }
-        $highlighter->highlight($words);
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Preprocessing/Fuzzy.php
===================================================================
--- Search/Lucene/Search/Query/Preprocessing/Fuzzy.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Preprocessing/Fuzzy.php	(Arbeitskopie)
@@ -213,53 +213,38 @@
         }
 
         // Word is tokenized into several tokens
-        require_once 'Zend/Search/Lucene/Search/QueryParserException.php';
-        throw new Zend_Search_Lucene_Search_QueryParserException('Fuzzy search is supported only for non-multiple word terms');
-    }
+        $query = new Zend_Search_Lucene_Search_Query_Phrase();
+        $query->setBoost($this->getBoost());
+        $position = 0;
+        $termsadded = 0;
+        foreach ($tokens as $token) {
 
-    /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        /** Skip fields detection. We don't need it, since we expect all fields presented in the HTML body and don't differentiate them */
+            // Find matching terms to individual token fuzzy searches
+            $term  = new Zend_Search_Lucene_Index_Term($token->getTermText(), $this->_field);
+            $subquery = new Zend_Search_Lucene_Search_Query_Fuzzy($term, $this->_minimumSimilarity);
+            $subquery->setBoost($this->getBoost());
 
-        /** Skip exact term matching recognition, keyword fields highlighting is not supported */
-
-        // -------------------------------------
-        // Recognize wildcard queries
-
-        /** @todo check for PCRE unicode support may be performed through Zend_Environment in some future */
-        if (@preg_match('/\pL/u', 'a') == 1) {
-            $subPatterns = preg_split('/[*?]/u', iconv($this->_encoding, 'UTF-8', $this->_word));
-        } else {
-            $subPatterns = preg_split('/[*?]/', $this->_word);
+            // Add all found terms for each wildcard into the corresponding positions of the phrase query
+            $terms = $subquery->rewrite($index)->getQueryTerms();
+            if ($termsadded == 1) {
+                $position += $token->getPositionIncrement();
+            }
+            foreach($terms as $term) {
+                $query->addTerm($term, $position);
+                $termsadded = 1;
+            }
         }
-        if (count($subPatterns) > 1) {
-            // Do nothing
-            return;
-        }
 
-        // -------------------------------------
-        // Recognize one-term multi-term and "insignificant" queries
-        $tokens = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($this->_word, $this->_encoding);
-        if (count($tokens) == 0) {
-            // Do nothing
-            return;
+        if ($termsadded == 0) {
+            $this->_matches = array();
+            return new Zend_Search_Lucene_Search_Query_Insignificant();
         }
-        if (count($tokens) == 1) {
-            $term  = new Zend_Search_Lucene_Index_Term($tokens[0]->getTermText(), $this->_field);
-            $query = new Zend_Search_Lucene_Search_Query_Fuzzy($term, $this->_minimumSimilarity);
 
-            $query->_highlightMatches($highlighter);
-            return;
-        }
+        // Get rewritten query. Important! It also fills terms matching container.
+        $rewrittenQuery = $query->rewrite($index);
+        $this->_matches = $query->getQueryTerms();
 
-        // Word is tokenized into several tokens
-        // But fuzzy search is supported only for non-multiple word terms
-        // Do nothing
+        return $rewrittenQuery;
     }
 
     /**
Index: Search/Lucene/Search/Query/Preprocessing/Term.php
===================================================================
--- Search/Lucene/Search/Query/Preprocessing/Term.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Preprocessing/Term.php	(Arbeitskopie)
@@ -157,10 +157,12 @@
             $word = iconv($this->_encoding, 'UTF-8', $this->_word);
             $wildcardsPattern = '/[*?]/u';
             $subPatternsEncoding = 'UTF-8';
+            $utf8Support = 1;
         } else {
             $word = $this->_word;
             $wildcardsPattern = '/[*?]/';
             $subPatternsEncoding = $this->_encoding;
+            $utf8Support = 0;
         }
 
         $subPatterns = preg_split($wildcardsPattern, $word, -1, PREG_SPLIT_OFFSET_CAPTURE);
@@ -168,29 +170,121 @@
         if (count($subPatterns) > 1) {
             // Wildcard query is recognized
 
-            $pattern = '';
+            $patterns   = array('');
+            $subqueries = array();
+            $position   = 0;
 
             foreach ($subPatterns as $id => $subPattern) {
                 // Append corresponding wildcard character to the pattern before each sub-pattern (except first)
                 if ($id != 0) {
-                    $pattern .= $word[ $subPattern[1] - 1 ];
+                    foreach ($patterns as $key => $pattern) {
+                            $patterns[$key] .= $word[ $subPattern[1] - 1 ];
+                    }
                 }
 
                 // Check if each subputtern is a single word in terms of current analyzer
                 $tokens = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($subPattern[0], $subPatternsEncoding);
-                if (count($tokens) > 1) {
-                    require_once 'Zend/Search/Lucene/Search/QueryParserException.php';
-                    throw new Zend_Search_Lucene_Search_QueryParserException('Wildcard search is supported only for non-multiple word terms');
+
+                // Find out if start of subpattern is also a forced token boundary
+                // (i.e. non-indexed character) in terms of current analyzer
+                /** @todo check for PCRE unicode support may be performed through Zend_Environment in some future */
+                $references=array();
+                if ($utf8Support) {
+                    preg_match('/^./u',$subPattern[0],$references);
+                } else {
+                    preg_match('/^./',$subPattern[0],$references);
                 }
-                foreach ($tokens as $token) {
-                    $pattern .= $token->getTermText();
+                if (!count($references)) {
+                        $references = array('');
                 }
+                // $references[0] is supposed to hold the first (possibly multi byte) character of $subPattern[0]
+                // if it is tokenized empty, (but the current subpattern is not empty) then the 
+                // current subpattern begins with a word boundary character in terms of current analyzer
+                // in this case, the pattern needs to be split at this point. Example: foo*_bar
+                $tokentest = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($references[0], $subPatternsEncoding);
+                if ($subPattern[0] != '' && count($tokentest) == 0) {
+                        // There might be several alternative patterns for the token string so far.
+                        // Save them all as queries in array
+                        foreach ($patterns as $pattern) {
+                            $term  = new Zend_Search_Lucene_Index_Term($pattern, $this->_field);
+                            $query = new Zend_Search_Lucene_Search_Query_Wildcard($term);
+                            $query->setBoost($this->getBoost());
+                            $subqueries[] = array($query, $position);
+                        }
+                        $patterns = array('');
+                        $position++;
+                }
+
+                // Add to array of search-tokens for each token in analyzed string
+                foreach ($tokens as $num => $token) {
+                    if ($num == 0) {
+                        // The very first token, only adds to pattern string(s) as normal
+                        $oldpatterns = $patterns;
+                        foreach ($patterns as $key => $pattern) {
+                            $patterns[$key] .= $token->getTermText();
+                        }
+                    } else {
+                        // On additional tokens check whether they are marked as alternatives (positionIcrement==0)
+                        if ($token->getPositionIncrement() == 0) {
+                            // If so, create alternative patterns for this alternative
+                            foreach($oldpatterns as $oldpattern) {
+                                    $patterns[] = $oldpattern.$token->getTermText();
+                            }
+                        } else {
+                            // Otherwise store all previous patterns as wildcard queries in array
+                            foreach ($patterns as $pattern) {
+                                $term  = new Zend_Search_Lucene_Index_Term($pattern, $this->_field);
+                                $query = new Zend_Search_Lucene_Search_Query_Wildcard($term);
+                                $query->setBoost($this->getBoost());
+                                $subqueries[] = array($query, $position);
+                            }
+                            // Increase the position in the phrase query
+                            $position += $token->getPositionIncrement();
+                            // And store this very current token as only alternative in pattern array
+                            $oldpatterns = array('');
+                            $patterns = array($token->getTermText());
+                        }
+                    }
+                }
             }
+            
+            // If we ended up with more than one (sub)query, we need to assemble a phrase request.
+            if (count($subqueries) || count($patterns)>1) {
+                // The latest wildcard patterns have not been added to the array yet
+                foreach ($patterns as $pattern) {
+                    $term  = new Zend_Search_Lucene_Index_Term($pattern, $this->_field);
+                    $query = new Zend_Search_Lucene_Search_Query_Wildcard($term);
+                    $query->setBoost($this->getBoost());
+                    $subqueries[] = array($query, $position);
+                }
 
-            $term  = new Zend_Search_Lucene_Index_Term($pattern, $this->_field);
-            $query = new Zend_Search_Lucene_Search_Query_Wildcard($term);
-            $query->setBoost($this->getBoost());
+                // Create a new Phrase query
+                $query = new Zend_Search_Lucene_Search_Query_Phrase();
+                $query->setBoost($this->getBoost());
+                $termsadded = 0;
 
+                // Add all found terms for each wildcard into the corresponding positions of the phrase query
+                foreach ($subqueries as &$subarray) {
+                    list($subquery, $position)=$subarray;
+                    $terms = $subquery->rewrite($index)->getQueryTerms();
+                    foreach($terms as $term) {
+                        $query->addTerm($term, $position);
+                        $termsadded = 1;
+                    }
+                }
+
+                // If none were found the entire query is insignificant.
+                if ($termsadded == 0) {
+                    $this->_matches = array();
+                    return new Zend_Search_Lucene_Search_Query_Insignificant();
+                }
+            } else {
+                // Single wildcard query. Behave as normal.
+                $term  = new Zend_Search_Lucene_Index_Term($patterns[0], $this->_field);
+                $query = new Zend_Search_Lucene_Search_Query_Wildcard($term);
+                $query->setBoost($this->getBoost());
+            }
+
             // Get rewritten query. Important! It also fills terms matching container.
             $rewrittenQuery = $query->rewrite($index);
             $this->_matches = $query->getQueryTerms();
@@ -234,83 +328,7 @@
         $this->_matches = $query->getQueryTerms();
         return $query;
     }
-
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        /** Skip fields detection. We don't need it, since we expect all fields presented in the HTML body and don't differentiate them */
-
-        /** Skip exact term matching recognition, keyword fields highlighting is not supported */
-
-        // -------------------------------------
-        // Recognize wildcard queries
-        /** @todo check for PCRE unicode support may be performed through Zend_Environment in some future */
-        if (@preg_match('/\pL/u', 'a') == 1) {
-            $word = iconv($this->_encoding, 'UTF-8', $this->_word);
-            $wildcardsPattern = '/[*?]/u';
-            $subPatternsEncoding = 'UTF-8';
-        } else {
-            $word = $this->_word;
-            $wildcardsPattern = '/[*?]/';
-            $subPatternsEncoding = $this->_encoding;
-        }
-        $subPatterns = preg_split($wildcardsPattern, $word, -1, PREG_SPLIT_OFFSET_CAPTURE);
-        if (count($subPatterns) > 1) {
-            // Wildcard query is recognized
-
-            $pattern = '';
-
-            foreach ($subPatterns as $id => $subPattern) {
-                // Append corresponding wildcard character to the pattern before each sub-pattern (except first)
-                if ($id != 0) {
-                    $pattern .= $word[ $subPattern[1] - 1 ];
-                }
-
-                // Check if each subputtern is a single word in terms of current analyzer
-                $tokens = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($subPattern[0], $subPatternsEncoding);
-                if (count($tokens) > 1) {
-                    // Do nothing (nothing is highlighted)
-                    return;
-                }
-                foreach ($tokens as $token) {
-                    $pattern .= $token->getTermText();
-                }
-            }
-
-            $term  = new Zend_Search_Lucene_Index_Term($pattern, $this->_field);
-            $query = new Zend_Search_Lucene_Search_Query_Wildcard($term);
-
-            $query->_highlightMatches($highlighter);
-            return;
-        }
-
-        // -------------------------------------
-        // Recognize one-term multi-term and "insignificant" queries
-        $tokens = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($this->_word, $this->_encoding);
-
-        if (count($tokens) == 0) {
-            // Do nothing
-            return;
-        }
-
-        if (count($tokens) == 1) {
-            $highlighter->highlight($tokens[0]->getTermText());
-            return;
-        }
-
-        //It's not insignificant or one term query
-        $words = array();
-        foreach ($tokens as $token) {
-            $words[] = $token->getTermText();
-        }
-        $highlighter->highlight($words);
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Empty.php
===================================================================
--- Search/Lucene/Search/Query/Empty.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Empty.php	(Arbeitskopie)
@@ -118,16 +118,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        // Do nothing
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Boolean.php
===================================================================
--- Search/Lucene/Search/Query/Boolean.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Boolean.php	(Arbeitskopie)
@@ -758,20 +758,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        foreach ($this->_subqueries as $id => $subquery) {
-            if ($this->_signs === null  ||  $this->_signs[$id] !== false) {
-                $subquery->_highlightMatches($highlighter);
-            }
-        }
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/MultiTerm.php
===================================================================
--- Search/Lucene/Search/Query/MultiTerm.php	(Revision 17917)
+++ Search/Lucene/Search/Query/MultiTerm.php	(Arbeitskopie)
@@ -600,30 +600,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        $words = array();
-
-        if ($this->_signs === null) {
-            foreach ($this->_terms as $term) {
-                $words[] = $term->text;
-            }
-        } else {
-            foreach ($this->_signs as $id => $sign) {
-                if ($sign !== false) {
-                    $words[] = $this->_terms[$id]->text;
-                }
-            }
-        }
-
-        $highlighter->highlight($words);
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Phrase.php
===================================================================
--- Search/Lucene/Search/Query/Phrase.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Phrase.php	(Arbeitskopie)
@@ -518,21 +518,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        $words = array();
-        foreach ($this->_terms as $term) {
-            $words[] = $term->text;
-        }
-
-        $highlighter->highlight($words);
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Insignificant.php
===================================================================
--- Search/Lucene/Search/Query/Insignificant.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Insignificant.php	(Arbeitskopie)
@@ -119,16 +119,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        // Do nothing
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Fuzzy.php
===================================================================
--- Search/Lucene/Search/Query/Fuzzy.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Fuzzy.php	(Arbeitskopie)
@@ -410,68 +410,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        $words = array();
-
-        $prefix           = Zend_Search_Lucene_Index_Term::getPrefix($this->_term->text, $this->_prefixLength);
-        $prefixByteLength = strlen($prefix);
-        $prefixUtf8Length = Zend_Search_Lucene_Index_Term::getLength($prefix);
-
-        $termLength       = Zend_Search_Lucene_Index_Term::getLength($this->_term->text);
-
-        $termRest         = substr($this->_term->text, $prefixByteLength);
-        // we calculate length of the rest in bytes since levenshtein() is not UTF-8 compatible
-        $termRestLength   = strlen($termRest);
-
-        $scaleFactor = 1/(1 - $this->_minimumSimilarity);
-
-
-        $docBody = $highlighter->getDocument()->getFieldUtf8Value('body');
-        $tokens = Zend_Search_Lucene_Analysis_Analyzer::getDefault()->tokenize($docBody, 'UTF-8');
-        foreach ($tokens as $token) {
-            $termText = $token->getTermText();
-
-            if (substr($termText, 0, $prefixByteLength) == $prefix) {
-                // Calculate similarity
-                $target = substr($termText, $prefixByteLength);
-
-                $maxDistance = isset($this->_maxDistances[strlen($target)])?
-                                   $this->_maxDistances[strlen($target)] :
-                                   $this->_calculateMaxDistance($prefixUtf8Length, $termRestLength, strlen($target));
-
-                if ($termRestLength == 0) {
-                    // we don't have anything to compare.  That means if we just add
-                    // the letters for current term we get the new word
-                    $similarity = (($prefixUtf8Length == 0)? 0 : 1 - strlen($target)/$prefixUtf8Length);
-                } else if (strlen($target) == 0) {
-                    $similarity = (($prefixUtf8Length == 0)? 0 : 1 - $termRestLength/$prefixUtf8Length);
-                } else if ($maxDistance < abs($termRestLength - strlen($target))){
-                    //just adding the characters of term to target or vice-versa results in too many edits
-                    //for example "pre" length is 3 and "prefixes" length is 8.  We can see that
-                    //given this optimal circumstance, the edit distance cannot be less than 5.
-                    //which is 8-3 or more precisesly abs(3-8).
-                    //if our maximum edit distance is 4, then we can discard this word
-                    //without looking at it.
-                    $similarity = 0;
-                } else {
-                    $similarity = 1 - levenshtein($termRest, $target)/($prefixUtf8Length + min($termRestLength, strlen($target)));
-                }
-
-                if ($similarity > $this->_minimumSimilarity) {
-                    $words[] = $termText;
-                }
-            }
-        }
-
-        $highlighter->highlight($words);
-    }
-
-    /**
      * Print a query
      *
      * @return string
Index: Search/Lucene/Search/Query/Term.php
===================================================================
--- Search/Lucene/Search/Query/Term.php	(Revision 17917)
+++ Search/Lucene/Search/Query/Term.php	(Arbeitskopie)
@@ -192,16 +192,6 @@
     }
 
     /**
-     * Query specific matches highlighting
-     *
-     * @param Zend_Search_Lucene_Search_Highlighter_Interface $highlighter  Highlighter object (also contains doc for highlighting)
-     */
-    protected function _highlightMatches(Zend_Search_Lucene_Search_Highlighter_Interface $highlighter)
-    {
-        $highlighter->highlight($this->_term->text);
-    }
-
-    /**
      * Print a query
      *
      * @return string
